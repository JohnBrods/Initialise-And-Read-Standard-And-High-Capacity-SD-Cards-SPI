                                                    /*Anyone is free to copy, modify, publish, use, compile or
                                                    distribute this software, either in source code form or as a compiled
                                                    binary, for non-commercial use only. (i.e. YOU MAY NOT SELL IT)
                                                    John B 3/11/2021

                                                    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                                                    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                                                    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                                                    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
                                                    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
                                                    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
                                                    OTHER DEALINGS IN THE SOFTWARE.*/
                                                    //Initialise an SD Card with SPI SD OR SD HC FAT16 or FAT32
                                                    //Read SD Card Boot Sector or any other
                                                    //I Would Like A Mention If You Demo It.
                                                    //Like All My C Files, It Has My Own 'Write Number' Function, It's Fast :)
                                                    //To Donate A Coffee, See Link In Youtube Where You Found This File, Thank You.

const unsigned short Tahoma25x27[] = {
   0x00,
   0x00,
   0x20,0x00,
   0x7F,0x00,
   0x1B,
   0x00,
   0x01,0x88,0x01,0x00,
   0x06,0xA3,0x01,0x00,
   0x0A,0xBE,0x01,0x00,
   0x12,0xF4,0x01,0x00,
   0x0E,0x45,0x02,0x00,
   0x19,0x7B,0x02,0x00,
   0x13,0xE7,0x02,0x00,
   0x04,0x38,0x03,0x00,
   0x09,0x53,0x03,0x00,
   0x09,0x89,0x03,0x00,
   0x0E,0xBF,0x03,0x00,
   0x12,0xF5,0x03,0x00,
   0x07,0x46,0x04,0x00,
   0x08,0x61,0x04,0x00,
   0x06,0x7C,0x04,0x00,
   0x0A,0x97,0x04,0x00,
   0x0E,0xCD,0x04,0x00,
   0x0E,0x03,0x05,0x00,
   0x0E,0x39,0x05,0x00,
   0x0D,0x6F,0x05,0x00,
   0x0E,0xA5,0x05,0x00,
   0x0E,0xDB,0x05,0x00,
   0x0E,0x11,0x06,0x00,
   0x0D,0x47,0x06,0x00,
   0x0E,0x7D,0x06,0x00,
   0x0E,0xB3,0x06,0x00,
   0x06,0xE9,0x06,0x00,
   0x07,0x04,0x07,0x00,
   0x11,0x1F,0x07,0x00,
   0x12,0x70,0x07,0x00,
   0x11,0xC1,0x07,0x00,
   0x0C,0x12,0x08,0x00,
   0x17,0x48,0x08,0x00,
   0x10,0x99,0x08,0x00,
   0x0F,0xCF,0x08,0x00,
   0x0F,0x05,0x09,0x00,
   0x11,0x3B,0x09,0x00,
   0x0E,0x8C,0x09,0x00,
   0x0E,0xC2,0x09,0x00,
   0x11,0xF8,0x09,0x00,
   0x10,0x49,0x0A,0x00,
   0x0A,0x7F,0x0A,0x00,
   0x09,0xB5,0x0A,0x00,
   0x10,0xEB,0x0A,0x00,
   0x0D,0x21,0x0B,0x00,
   0x13,0x57,0x0B,0x00,
   0x10,0xA8,0x0B,0x00,
   0x12,0xDE,0x0B,0x00,
   0x0F,0x2F,0x0C,0x00,
   0x12,0x65,0x0C,0x00,
   0x11,0xB6,0x0C,0x00,
   0x0E,0x07,0x0D,0x00,
   0x11,0x3D,0x0D,0x00,
   0x10,0x8E,0x0D,0x00,
   0x10,0xC4,0x0D,0x00,
   0x18,0xFA,0x0D,0x00,
   0x10,0x4B,0x0E,0x00,
   0x11,0x81,0x0E,0x00,
   0x0E,0xD2,0x0E,0x00,
   0x09,0x08,0x0F,0x00,
   0x0B,0x3E,0x0F,0x00,
   0x08,0x74,0x0F,0x00,
   0x12,0x8F,0x0F,0x00,
   0x0F,0xE0,0x0F,0x00,
   0x09,0x16,0x10,0x00,
   0x0C,0x4C,0x10,0x00,
   0x0E,0x82,0x10,0x00,
   0x0B,0xB8,0x10,0x00,
   0x0D,0xEE,0x10,0x00,
   0x0D,0x24,0x11,0x00,
   0x09,0x5A,0x11,0x00,
   0x0D,0x90,0x11,0x00,
   0x0D,0xC6,0x11,0x00,
   0x05,0xFC,0x11,0x00,
   0x06,0x17,0x12,0x00,
   0x0E,0x32,0x12,0x00,
   0x05,0x68,0x12,0x00,
   0x15,0x83,0x12,0x00,
   0x0D,0xD4,0x12,0x00,
   0x0E,0x0A,0x13,0x00,
   0x0E,0x40,0x13,0x00,
   0x0D,0x76,0x13,0x00,
   0x0A,0xAC,0x13,0x00,
   0x0B,0xE2,0x13,0x00,
   0x09,0x18,0x14,0x00,
   0x0D,0x4E,0x14,0x00,
   0x0D,0x84,0x14,0x00,
   0x14,0xBA,0x14,0x00,
   0x0D,0x0B,0x15,0x00,
   0x0D,0x41,0x15,0x00,
   0x0B,0x77,0x15,0x00,
   0x0C,0xAD,0x15,0x00,
   0x07,0xE3,0x15,0x00,
   0x0C,0xFE,0x15,0x00,
   0x12,0x34,0x16,0x00,
   0x07,0x85,0x16,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 32
   0x00,0x00,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x00,0x00,0x38,0x38,0x38,0x00,0x00,0x00,0x00,0x00, // Code for char num 33
   0x00,0x00,0x9C,0x03,0x9C,0x03,0x9C,0x03,0x9C,0x03,0x9C,0x03,0x9C,0x03,0x9C,0x03,0x08,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 34
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC6,0x00,0x00,0xC6,0x00,0x00,0x63,0x00,0x00,0x63,0x00,0x00,0x63,0x00,0x00,0x63,0x00,0xF0,0xFF,0x03,0xF0,0xFF,0x03,0x80,0x31,0x00,0x80,0x31,0x00,0xC0,0x18,0x00,0xC0,0x18,0x00,0xC0,0x18,0x00,0xFC,0xFF,0x00,0xFC,0xFF,0x00,0x60,0x0C,0x00,0x60,0x0C,0x00,0x60,0x0C,0x00,0x30,0x06,0x00,0x30,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 35
   0x00,0x00,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0xE0,0x0F,0xF8,0x1F,0x9C,0x19,0x8E,0x11,0x8E,0x01,0x8E,0x01,0x9E,0x01,0xFC,0x01,0xF8,0x0F,0x80,0x1F,0x80,0x3D,0x80,0x39,0x80,0x39,0x82,0x39,0x8E,0x1D,0xFE,0x0F,0xF8,0x07,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01, // Code for char num 36
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x00,0x06,0x00,0xFC,0x01,0x03,0x00,0x8C,0x01,0x03,0x00,0x06,0x83,0x01,0x00,0x06,0x83,0x01,0x00,0x06,0xC3,0x00,0x00,0x06,0xC3,0x00,0x00,0x06,0x63,0x00,0x00,0x06,0x63,0x7C,0x00,0x8C,0x31,0xFE,0x00,0xFC,0x31,0xC6,0x00,0xF8,0x18,0x83,0x01,0x00,0x18,0x83,0x01,0x00,0x0C,0x83,0x01,0x00,0x0C,0x83,0x01,0x00,0x06,0x83,0x01,0x00,0x06,0x83,0x01,0x00,0x03,0xC6,0x00,0x00,0x03,0xFE,0x00,0x80,0x01,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 37
   0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x03,0x00,0xF8,0x07,0x00,0x38,0x0F,0x00,0x1C,0x0E,0x00,0x1C,0x0E,0x00,0x1C,0x0E,0x00,0x3C,0x06,0x00,0x78,0x07,0x00,0xF0,0xE3,0x00,0xF0,0xE1,0x00,0xD8,0xE3,0x00,0x9C,0xE7,0x00,0x0E,0xEF,0x00,0x0E,0x7E,0x00,0x0E,0x7C,0x00,0x0E,0x78,0x00,0x1E,0xF8,0x00,0x3C,0xFC,0x01,0xF8,0xCF,0x03,0xF0,0x83,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 38
   0x00,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 39
   0x00,0x00,0xC0,0x01,0xE0,0x00,0x70,0x00,0x38,0x00,0x38,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x1E,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x38,0x00,0x38,0x00,0x70,0x00,0xE0,0x00,0xC0,0x01, // Code for char num 40
   0x00,0x00,0x0E,0x00,0x1C,0x00,0x38,0x00,0x70,0x00,0x70,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xE0,0x01,0xE0,0x00,0xE0,0x00,0xE0,0x00,0x70,0x00,0x70,0x00,0x38,0x00,0x1C,0x00,0x0E,0x00, // Code for char num 41
   0x00,0x00,0x80,0x01,0x80,0x01,0x88,0x11,0x9C,0x39,0xF0,0x0F,0xC0,0x03,0xC0,0x03,0xF0,0x0F,0x9C,0x39,0x88,0x11,0x80,0x01,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 42
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0xFC,0xFF,0x03,0xFC,0xFF,0x03,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 43
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x38,0x38,0x18,0x1C,0x1C,0x0C,0x0E,0x06, // Code for char num 44
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 45
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x38,0x38,0x00,0x00,0x00,0x00,0x00, // Code for char num 46
   0x00,0x00,0x00,0x03,0x80,0x03,0x80,0x01,0x80,0x01,0x80,0x01,0xC0,0x00,0xC0,0x00,0xC0,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x18,0x00,0x18,0x00,0x18,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x07,0x00,0x03,0x00,0x00,0x00, // Code for char num 47
   0x00,0x00,0x00,0x00,0xE0,0x03,0xF8,0x0F,0x38,0x0E,0x1C,0x1C,0x1C,0x1C,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x1C,0x1C,0x1C,0x1C,0x38,0x0E,0xF8,0x0F,0xE0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 48
   0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x03,0xC0,0x03,0xF8,0x03,0xF8,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0xF8,0x3F,0xF8,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 49
   0x00,0x00,0x00,0x00,0xF0,0x03,0xFC,0x07,0x1C,0x0E,0x04,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x0E,0x00,0x0E,0x00,0x07,0x80,0x07,0xC0,0x03,0xC0,0x01,0xE0,0x00,0x70,0x00,0x38,0x00,0x1C,0x00,0xFC,0x3F,0xFC,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 50
   0x00,0x00,0x00,0x00,0xF0,0x03,0xFC,0x0F,0x1C,0x1E,0x04,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x0F,0xE0,0x03,0xE0,0x03,0x00,0x0E,0x00,0x0C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x02,0x0E,0x0E,0x0F,0xFE,0x07,0xF8,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 51
   0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x0F,0x80,0x0F,0xC0,0x0E,0xC0,0x0E,0x60,0x0E,0x30,0x0E,0x18,0x0E,0x0C,0x0E,0x0C,0x0E,0x06,0x0E,0xFE,0x3F,0xFE,0x3F,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 52
   0x00,0x00,0x00,0x00,0xF8,0x3F,0xF8,0x3F,0x38,0x00,0x38,0x00,0x38,0x00,0x38,0x00,0x38,0x00,0xF8,0x07,0xF8,0x0F,0x00,0x1E,0x00,0x3C,0x00,0x38,0x00,0x38,0x00,0x38,0x00,0x38,0x00,0x38,0x04,0x1C,0x1C,0x1E,0xFC,0x0F,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 53
   0x00,0x00,0x00,0x00,0x80,0x0F,0xE0,0x0F,0x70,0x08,0x38,0x00,0x1C,0x00,0x1C,0x00,0x0C,0x00,0xCE,0x07,0xFE,0x0F,0x1E,0x1E,0x0E,0x3C,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x1C,0x38,0x1C,0x1C,0x38,0x1E,0xF8,0x0F,0xE0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 54
   0x00,0x00,0x00,0x00,0xFE,0x1F,0xFE,0x1F,0x00,0x1C,0x00,0x1C,0x00,0x0E,0x00,0x0E,0x00,0x07,0x00,0x07,0x80,0x03,0x80,0x03,0xC0,0x01,0xC0,0x01,0xE0,0x00,0xE0,0x00,0xE0,0x00,0x70,0x00,0x70,0x00,0x38,0x00,0x38,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 55
   0x00,0x00,0x00,0x00,0xE0,0x07,0xF8,0x0F,0x1C,0x1C,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x1E,0x38,0x3C,0x1C,0xF8,0x0E,0xF0,0x07,0x9C,0x0F,0x1C,0x1E,0x0E,0x3C,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x1E,0x3C,0x3C,0x1E,0xF8,0x0F,0xE0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 56
   0x00,0x00,0x00,0x00,0xE0,0x03,0xF8,0x0F,0x3C,0x0E,0x1C,0x1C,0x0E,0x1C,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x1E,0x38,0x3C,0x3C,0xF8,0x3F,0xF0,0x39,0x00,0x18,0x00,0x1C,0x00,0x1C,0x00,0x0E,0x08,0x07,0xF8,0x03,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 57
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x38,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x38,0x38,0x00,0x00,0x00,0x00,0x00, // Code for char num 58
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x38,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x38,0x38,0x18,0x1C,0x1C,0x0C,0x0E,0x06, // Code for char num 59
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0xC0,0x01,0x00,0xF0,0x00,0x00,0x3C,0x00,0x00,0x0F,0x00,0xC0,0x03,0x00,0xF0,0x00,0x00,0x38,0x00,0x00,0xF0,0x00,0x00,0xC0,0x03,0x00,0x00,0x0F,0x00,0x00,0x3C,0x00,0x00,0xF0,0x00,0x00,0xC0,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 60
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x03,0xF8,0xFF,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x03,0xF8,0xFF,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 61
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x38,0x00,0x00,0xF0,0x00,0x00,0xC0,0x03,0x00,0x00,0x0F,0x00,0x00,0x3C,0x00,0x00,0xF0,0x00,0x00,0xC0,0x01,0x00,0xF0,0x00,0x00,0x3C,0x00,0x00,0x0F,0x00,0xC0,0x03,0x00,0xF0,0x00,0x00,0x38,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 62
   0x00,0x00,0x00,0x00,0xF8,0x01,0xFE,0x07,0x06,0x07,0x02,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x07,0x80,0x07,0xC0,0x03,0xE0,0x01,0x70,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 63
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x80,0xFF,0x03,0xC0,0x03,0x0F,0xE0,0x00,0x1C,0x70,0x00,0x18,0x30,0xFC,0x31,0x18,0xFE,0x31,0x18,0x87,0x71,0x8C,0x83,0x61,0x8C,0x81,0x61,0x8C,0x81,0x61,0x8C,0x81,0x61,0x8C,0x81,0x61,0x8C,0x81,0x61,0x8C,0x81,0x61,0x18,0xC3,0x31,0x18,0xFF,0x3F,0x38,0xBC,0x1F,0x70,0x00,0x00,0xE0,0x00,0x00,0xC0,0x03,0x01,0x80,0xFF,0x01,0x00,0xFE,0x01,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 64
   0x00,0x00,0x00,0x00,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xE0,0x07,0xE0,0x07,0xE0,0x07,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x38,0x1C,0x38,0x1C,0x38,0x1C,0xFC,0x3F,0xFC,0x3F,0x1C,0x38,0x1E,0x78,0x0E,0x70,0x0E,0x70,0x0F,0xF0,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 65
   0x00,0x00,0x00,0x00,0xFC,0x07,0xFC,0x1F,0x1C,0x3C,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x1C,0xFC,0x0F,0xFC,0x1F,0x1C,0x38,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x38,0x1C,0x3C,0xFC,0x1F,0xFC,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 66
   0x00,0x00,0x00,0x00,0xC0,0x0F,0xE0,0x7F,0x78,0x70,0x38,0x60,0x1C,0x40,0x1C,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x1C,0x00,0x1C,0x40,0x38,0x60,0x78,0x70,0xF0,0x7F,0xC0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 67
   0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x07,0x00,0xFC,0x1F,0x00,0x1C,0x3C,0x00,0x1C,0x70,0x00,0x1C,0xE0,0x00,0x1C,0xE0,0x00,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x1C,0xE0,0x00,0x1C,0xE0,0x00,0x1C,0x70,0x00,0x1C,0x3C,0x00,0xFC,0x1F,0x00,0xFC,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 68
   0x00,0x00,0x00,0x00,0xFC,0x3F,0xFC,0x3F,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0xFC,0x1F,0xFC,0x1F,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0xFC,0x3F,0xFC,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 69
   0x00,0x00,0x00,0x00,0xFC,0x3F,0xFC,0x3F,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0xFC,0x3F,0xFC,0x3F,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 70
   0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3F,0x00,0xE0,0xFF,0x00,0xF0,0xE0,0x01,0x38,0x80,0x01,0x1C,0x00,0x01,0x1C,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0xFC,0x01,0x0E,0xFC,0x01,0x0E,0xC0,0x01,0x0E,0xC0,0x01,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x38,0xC0,0x01,0xF0,0xC0,0x01,0xE0,0xFF,0x01,0x80,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 71
   0x00,0x00,0x00,0x00,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0xFC,0xFF,0xFC,0xFF,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 72
   0x00,0x00,0x00,0x00,0xFE,0x03,0xFE,0x03,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0xFE,0x03,0xFE,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 73
   0x00,0x00,0x00,0x00,0xFC,0x01,0xFC,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xE1,0x00,0xFF,0x00,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 74
   0x00,0x00,0x00,0x00,0x1C,0xF0,0x1C,0x78,0x1C,0x3C,0x1C,0x1E,0x1C,0x0F,0x9C,0x07,0xDC,0x03,0xDC,0x01,0xFC,0x00,0xFC,0x00,0xFC,0x01,0xDC,0x03,0x9C,0x07,0x1C,0x07,0x1C,0x0F,0x1C,0x1E,0x1C,0x1C,0x1C,0x38,0x1C,0x78,0x1C,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 75
   0x00,0x00,0x00,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0xFC,0x1F,0xFC,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 76
   0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x80,0x07,0x7C,0xC0,0x07,0x7C,0xC0,0x07,0xFC,0xC0,0x07,0xDC,0x60,0x07,0xDC,0x60,0x07,0x9C,0x31,0x07,0x9C,0x31,0x07,0x9C,0x33,0x07,0x1C,0x1B,0x07,0x1C,0x1F,0x07,0x1C,0x0E,0x07,0x1C,0x0E,0x07,0x1C,0x04,0x07,0x1C,0x00,0x07,0x1C,0x00,0x07,0x1C,0x00,0x07,0x1C,0x00,0x07,0x1C,0x00,0x07,0x1C,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 77
   0x00,0x00,0x00,0x00,0x3C,0xE0,0x7C,0xE0,0x7C,0xE0,0xFC,0xE0,0xDC,0xE0,0xDC,0xE1,0x9C,0xE1,0x9C,0xE1,0x1C,0xE3,0x1C,0xE3,0x1C,0xE7,0x1C,0xE6,0x1C,0xEE,0x1C,0xEC,0x1C,0xEC,0x1C,0xF8,0x1C,0xF8,0x1C,0xF8,0x1C,0xF0,0x1C,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 78
   0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0xE0,0x3F,0x00,0x78,0xF0,0x00,0x38,0xE0,0x00,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x38,0xE0,0x00,0x78,0xF0,0x00,0xF0,0x3F,0x00,0xC0,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 79
   0x00,0x00,0x00,0x00,0xFC,0x07,0xFC,0x1F,0x1C,0x3C,0x1C,0x38,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x38,0x1C,0x3C,0xFC,0x1F,0xFC,0x07,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 80
   0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0xE0,0x3F,0x00,0x78,0xF0,0x00,0x38,0xE0,0x00,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x0E,0x80,0x03,0x1C,0xC0,0x01,0x1C,0xC0,0x01,0x38,0xE0,0x00,0x78,0xF0,0x00,0xE0,0x7F,0x00,0xC0,0x1F,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x38,0x00,0x00,0xF8,0x03,0x00,0xE0,0x03, // Code for char num 81
   0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x07,0x00,0xFC,0x0F,0x00,0x1C,0x1C,0x00,0x1C,0x38,0x00,0x1C,0x38,0x00,0x1C,0x38,0x00,0x1C,0x38,0x00,0x1C,0x38,0x00,0x1C,0x1C,0x00,0x1C,0x1E,0x00,0xFC,0x0F,0x00,0xFC,0x03,0x00,0x9C,0x07,0x00,0x1C,0x0F,0x00,0x1C,0x1E,0x00,0x1C,0x1C,0x00,0x1C,0x3C,0x00,0x1C,0x78,0x00,0x1C,0xF0,0x00,0x1C,0xE0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 82
   0x00,0x00,0x00,0x00,0xE0,0x07,0xF8,0x1F,0x3C,0x1C,0x0E,0x10,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x1E,0x00,0x7C,0x00,0xF8,0x07,0xE0,0x0F,0x00,0x1E,0x00,0x3C,0x00,0x38,0x00,0x38,0x02,0x38,0x06,0x1C,0x1E,0x1E,0xFE,0x0F,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 83
   0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x01,0xFF,0xFF,0x01,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 84
   0x00,0x00,0x00,0x00,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x38,0x70,0x78,0x78,0xF0,0x3F,0xC0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 85
   0x00,0x00,0x00,0x00,0x07,0xE0,0x0F,0xF0,0x0E,0x70,0x0E,0x70,0x1E,0x78,0x1C,0x38,0x1C,0x38,0x3C,0x3C,0x38,0x1C,0x38,0x1C,0x78,0x1E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0xE0,0x07,0xE0,0x07,0xE0,0x07,0xC0,0x03,0xC0,0x03,0xC0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 86
   0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x18,0xE0,0x07,0x3C,0xE0,0x0E,0x3C,0x70,0x0E,0x3C,0x70,0x0E,0x3C,0x70,0x0E,0x76,0x70,0x1C,0x66,0x38,0x1C,0x66,0x38,0x1C,0x66,0x38,0x1C,0xE3,0x38,0x38,0xC3,0x1C,0x38,0xC3,0x1C,0x38,0xC3,0x1C,0xB8,0xC1,0x1D,0xF0,0x81,0x0F,0xF0,0x81,0x0F,0xF0,0x81,0x0F,0xF0,0x81,0x0F,0xE0,0x00,0x07,0xE0,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 87
   0x00,0x00,0x00,0x00,0x07,0xE0,0x0E,0x70,0x1C,0x38,0x1C,0x38,0x38,0x1C,0x70,0x0E,0x70,0x0E,0xE0,0x07,0xE0,0x03,0xC0,0x03,0xC0,0x03,0xE0,0x03,0xE0,0x07,0x70,0x0E,0x70,0x0E,0x38,0x1C,0x1C,0x38,0x1C,0x38,0x0E,0x70,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 88
   0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xE0,0x01,0x0E,0xE0,0x00,0x1C,0x70,0x00,0x3C,0x78,0x00,0x38,0x38,0x00,0x78,0x3C,0x00,0x70,0x1E,0x00,0xE0,0x0E,0x00,0xE0,0x0F,0x00,0xC0,0x07,0x00,0xC0,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 89
   0x00,0x00,0x00,0x00,0xFE,0x3F,0xFE,0x3F,0x00,0x38,0x00,0x1C,0x00,0x0E,0x00,0x0E,0x00,0x07,0x00,0x07,0x80,0x03,0xC0,0x01,0xC0,0x01,0xE0,0x00,0x70,0x00,0x70,0x00,0x38,0x00,0x38,0x00,0x1C,0x00,0x0E,0x00,0xFE,0x3F,0xFE,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 90
   0x00,0x00,0xFC,0x01,0xFC,0x01,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0xFC,0x01,0xFC,0x01, // Code for char num 91
   0x00,0x00,0x06,0x00,0x0E,0x00,0x0C,0x00,0x0C,0x00,0x1C,0x00,0x18,0x00,0x18,0x00,0x18,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x03,0x00,0x03,0x00,0x03,0x00,0x07,0x00,0x06,0x00,0x00, // Code for char num 92
   0x00,0xFE,0xFE,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xFE,0xFE, // Code for char num 93
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x0F,0x00,0x00,0x0F,0x00,0x80,0x19,0x00,0xC0,0x30,0x00,0xC0,0x30,0x00,0x60,0x60,0x00,0x70,0xC0,0x00,0x30,0xC0,0x00,0x18,0x80,0x01,0x1C,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 94
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x7F,0xFF,0x7F,0x00,0x00, // Code for char num 95
   0x78,0x00,0x70,0x00,0xE0,0x00,0xC0,0x00,0xC0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 96
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x01,0xFC,0x07,0x04,0x0F,0x00,0x0E,0x00,0x0E,0xE0,0x0F,0xF8,0x0F,0x3C,0x0E,0x1E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x1E,0x0F,0xFC,0x0E,0x78,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 97
   0x00,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x9C,0x07,0xFC,0x0F,0x7C,0x1C,0x1C,0x1C,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x1C,0x3C,0x1E,0xFC,0x0F,0xDC,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 98
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x03,0xF8,0x07,0x3C,0x06,0x1C,0x04,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x1C,0x04,0x3C,0x06,0xF8,0x07,0xE0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 99
   0x00,0x00,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0xE0,0x1D,0xF8,0x1F,0x3C,0x1E,0x1C,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x1C,0x1C,0x1C,0x1F,0xF8,0x1F,0xF0,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 100
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x03,0xF8,0x07,0x3C,0x0E,0x1C,0x1C,0x0E,0x1C,0x0E,0x1C,0xFE,0x1F,0xFE,0x1F,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x1C,0x10,0x3C,0x18,0xF8,0x1F,0xE0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 101
   0x00,0x00,0xF0,0x01,0xF8,0x01,0x38,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0xFF,0x00,0xFF,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 102
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x1D,0xF8,0x1F,0x3C,0x1E,0x1C,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x1C,0x1C,0x1C,0x1E,0xF8,0x1F,0xF0,0x1C,0x00,0x1C,0x00,0x0C,0x04,0x0E,0xFC,0x07,0xFC,0x01, // Code for char num 103
   0x00,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x9C,0x07,0xDC,0x0F,0x3C,0x1E,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 104
   0x00,0x00,0x1C,0x1C,0x1C,0x00,0x00,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00, // Code for char num 105
   0x00,0x00,0x38,0x38,0x38,0x00,0x00,0x3E,0x3E,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x3C,0x1F,0x07, // Code for char num 106
   0x00,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x1E,0x1C,0x0F,0x1C,0x07,0x9C,0x03,0xDC,0x01,0xFC,0x00,0xFC,0x00,0xFC,0x01,0xDC,0x01,0x9C,0x03,0x9C,0x07,0x1C,0x07,0x1C,0x0E,0x1C,0x1E,0x1C,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 107
   0x00,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00, // Code for char num 108
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9C,0x87,0x07,0xDC,0xCF,0x0F,0x7C,0x7E,0x1E,0x3C,0x3C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 109
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9C,0x07,0xDC,0x0F,0x3C,0x1E,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 110
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x03,0xF8,0x0F,0x3C,0x1E,0x1C,0x1C,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x1C,0x1C,0x3C,0x1E,0xF8,0x0F,0xE0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 111
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9C,0x07,0xFC,0x0F,0x3C,0x1C,0x1C,0x1C,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x1C,0x3C,0x1E,0xFC,0x0F,0xDC,0x07,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00, // Code for char num 112
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x1D,0xF8,0x1F,0x3C,0x1E,0x1C,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x0E,0x1C,0x1C,0x1C,0x1C,0x1E,0xF8,0x1F,0xF0,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C, // Code for char num 113
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9C,0x03,0xDC,0x03,0xFC,0x03,0x7C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 114
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x01,0xFC,0x03,0x1E,0x03,0x0E,0x02,0x0E,0x00,0x0E,0x00,0x7E,0x00,0xFC,0x03,0xF0,0x07,0x80,0x07,0x00,0x07,0x02,0x07,0x86,0x07,0xFE,0x03,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 115
   0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0xFF,0x01,0xFF,0x01,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x3C,0x00,0xF8,0x01,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 116
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1E,0x3C,0x1F,0xF8,0x1D,0xF0,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 117
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x1C,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x1C,0x07,0x1C,0x07,0x1C,0x07,0xB8,0x03,0xB8,0x03,0xB8,0x03,0xF0,0x01,0xF0,0x01,0xF0,0x00,0xE0,0x00,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 118
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x06,0x0E,0x07,0x0E,0x0E,0x0E,0x0F,0x07,0x0E,0x0F,0x07,0x0E,0x1F,0x07,0x8E,0x19,0x07,0x8C,0x19,0x03,0x9C,0x39,0x03,0xDC,0xB0,0x03,0xDC,0xB0,0x03,0xD8,0xF0,0x01,0x78,0xE0,0x01,0x78,0xE0,0x01,0x70,0xE0,0x01,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 119
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x1C,0x0E,0x0E,0x1C,0x07,0x1C,0x07,0xB8,0x03,0xF0,0x01,0xF0,0x01,0xE0,0x00,0xF0,0x01,0xF0,0x01,0xB8,0x03,0x1C,0x07,0x1C,0x07,0x0E,0x0E,0x07,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 120
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x1C,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x1C,0x07,0x1C,0x07,0xBC,0x03,0xB8,0x03,0xB8,0x03,0xF0,0x01,0xF0,0x01,0xF0,0x01,0xE0,0x00,0xE0,0x00,0x70,0x00,0x70,0x00,0x78,0x00,0x38,0x00,0x38,0x00,0x1C,0x00, // Code for char num 121
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x07,0xFE,0x07,0x00,0x07,0x80,0x03,0xC0,0x01,0xC0,0x01,0xE0,0x00,0xF0,0x00,0x70,0x00,0x38,0x00,0x38,0x00,0x1C,0x00,0x0E,0x00,0xFE,0x07,0xFE,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 122
   0x00,0x00,0x00,0x0F,0xC0,0x0F,0xC0,0x01,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0x70,0x00,0x38,0x00,0x1E,0x00,0x1E,0x00,0x38,0x00,0x70,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xC0,0x01,0xC0,0x0F,0x00,0x0F, // Code for char num 123
   0x00,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70, // Code for char num 124
   0x00,0x00,0x1E,0x00,0x7E,0x00,0x70,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xC0,0x01,0x80,0x03,0x00,0x0F,0x00,0x0F,0x80,0x03,0xC0,0x01,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0x70,0x00,0x7E,0x00,0x1E,0x00, // Code for char num 125
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x01,0x03,0xF8,0x03,0x03,0x18,0x07,0x03,0x1C,0x86,0x01,0x0C,0x8E,0x01,0x0C,0xFC,0x00,0x0C,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 126
   0x00,0x7E,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x7E,0x00,0x00,0x00,0x00,0x00,0x00 // Code for char num 127
  };

//GLCD FontName : San_Diego36x46
//GLCD FontSize : 36 x 46

const unsigned short Number_Fontlarge[] = {

   0x00,0xF0,0xF9,0x00,0x00,0x00,0xFC,0xF9,0x03,0x00,0x00,0xFF,0xF9,0x0F,0x00,0x80,0xFF,0xF0,0x1F,0x00,0xC0,0x7F,0xE0,0x3F,0x00,0xC0,0x3F,0xC0,0x3F,0x00,
   0xE0,0x3F,0xC0,0x7F,0x00,0xF0,0x3F,0xC0,0xFF,0x00,0xF0,0x3F,0xC0,0xFF,0x00,0xF8,0x3F,0xC0,0xFF,0x01,0xF8,0x3F,0xC0,0xFF,0x01,0xF8,0x3F,0xC0,0xFF,0x01,
   0xFC,0x3F,0xC0,0xFF,0x03,0xFC,0x3F,0xC0,0xFF,0x03,0xFC,0x3F,0xC0,0xFF,0x03,0xFC,0x3F,0xC0,0xFF,0x03,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,
   0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,
   0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,
   0xFC,0x3F,0xC0,0xFF,0x03,0xFC,0x3F,0xC0,0xFF,0x03,0xFC,0x3F,0xC0,0xFF,0x03,0xFC,0x3F,0xC0,0xFF,0x03,0xF8,0x3F,0xC0,0xFF,0x01,0xF8,0x3F,0xC0,0xFF,0x01,
   0xF8,0x3F,0xC0,0xFF,0x01,0xF0,0x3F,0xC0,0xFF,0x00,0xF0,0x3F,0xC0,0xFF,0x00,0xE0,0x3F,0xC0,0x7F,0x00,0xC0,0x3F,0xC0,0x3F,0x00,0xC0,0x7F,0xE0,0x3F,0x00,
   0x80,0xFF,0xF0,0x1F,0x00,0x00,0xFF,0xF9,0x0F,0x00,0x00,0xFC,0xF9,0x03,0x00,0x00,0xF0,0xF9,0x00,0x00, // Code for char num 48
   0x00,0x00,0x78,0x00,0x00,0x00,0xC0,0x7F,0x00,0x00,0x00,0xFF,0x7F,0x00,0x00,0x80,0xFF,0x7F,0x00,0x00,0x80,0xFF,0x7F,0x00,0x00,0x80,0xFF,0x7F,0x00,0x00,
   0x00,0xFE,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,
   0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,
   0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,
   0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,
   0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,
   0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xF8,0xFF,0x00,0x00,0x00,0xFF,0xFF,0x07,0x00,
   0x80,0xFF,0xFF,0x0F,0x00,0x80,0xFF,0xFF,0x0F,0x00,0x80,0xFF,0xFF,0x0F,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 49
   0x00,0x7C,0xFC,0x00,0x00,0x80,0x7F,0xFC,0x07,0x00,0xE0,0x7F,0xFC,0x0F,0x00,0xF0,0x1F,0xF0,0x3F,0x00,0xF8,0x07,0xE0,0x7F,0x00,0xFC,0x0F,0xE0,0xFF,0x00,
   0xFC,0x1F,0xE0,0xFF,0x00,0xFE,0x3F,0xE0,0xFF,0x01,0xFE,0x3F,0xE0,0xFF,0x01,0xFE,0x3F,0xE0,0xFF,0x03,0xFE,0x3F,0xE0,0xFF,0x03,0xFE,0x3F,0xE0,0xFF,0x03,
   0xFE,0x3F,0xE0,0xFF,0x03,0xFC,0x1F,0xE0,0xFF,0x03,0xFC,0x1F,0xE0,0xFF,0x03,0xF8,0x0F,0xE0,0xFF,0x03,0xE0,0x03,0xF0,0xFF,0x03,0x00,0x00,0xF0,0xFF,0x01,
   0x00,0x00,0xF8,0xFF,0x01,0x00,0x00,0xF8,0xFF,0x01,0x00,0x00,0xFC,0xFF,0x00,0x00,0x00,0xFE,0x7F,0x00,0x00,0x00,0xFF,0x3F,0x00,0x00,0x80,0xFF,0x1F,0x00,
   0x00,0xE0,0xFF,0x0F,0x00,0x00,0xF0,0xFF,0x01,0x00,0x00,0xF8,0x7F,0x00,0x00,0x00,0xFC,0x0F,0x00,0x00,0x00,0xFE,0x01,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,
   0x00,0x1F,0x00,0x00,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0xFF,0x01,0x80,0x07,0xC0,0xFF,0x3F,0xC0,0x07,
   0xF0,0xFF,0xFF,0xFF,0x07,0xF8,0xFF,0xFF,0xFF,0x07,0xF8,0xFF,0xFF,0xFF,0x03,0xFC,0xFF,0xFF,0xFF,0x03,0xFC,0xFF,0xFF,0xFF,0x03,0xFE,0xFF,0xFF,0xFF,0x01,
   0x7E,0xF0,0xFF,0xFF,0x00,0x1E,0x80,0xFF,0x7F,0x00,0x0E,0x00,0xFE,0x3F,0x00,0x00,0x00,0xF0,0x0F,0x00, // Code for char num 50
   0x00,0x7C,0xFC,0x00,0x00,0x00,0x7F,0xFC,0x07,0x00,0xC0,0x7F,0xFC,0x1F,0x00,0xE0,0x1F,0xF8,0x3F,0x00,0xF0,0x0F,0xE0,0x7F,0x00,0xF8,0x1F,0xE0,0xFF,0x00,
   0xF8,0x3F,0xC0,0xFF,0x01,0xFC,0x3F,0xC0,0xFF,0x01,0xFC,0x7F,0xC0,0xFF,0x03,0xFC,0x7F,0xC0,0xFF,0x03,0xFC,0x7F,0xC0,0xFF,0x03,0xFC,0x7F,0xC0,0xFF,0x03,
   0xFC,0x7F,0xC0,0xFF,0x03,0xF8,0x3F,0xC0,0xFF,0x03,0xF8,0x3F,0xC0,0xFF,0x03,0xF0,0x1F,0xC0,0xFF,0x01,0xC0,0x07,0xC0,0xFF,0x01,0x00,0x00,0xC0,0xFF,0x00,
   0x00,0x00,0xE0,0xFF,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xFE,0x3F,0x00,0x00,0x80,0xFF,0x0F,0x00,0x00,0x80,0xFF,0x07,0x00,0x00,0x80,0xFF,0x1F,0x00,
   0x00,0x00,0xF8,0x7F,0x00,0x00,0x00,0xE0,0xFF,0x00,0x00,0x00,0xC0,0xFF,0x01,0x00,0x00,0xC0,0xFF,0x01,0x00,0x00,0xC0,0xFF,0x03,0xE0,0x03,0xC0,0xFF,0x03,
   0xF8,0x0F,0xC0,0xFF,0x07,0xFC,0x1F,0xC0,0xFF,0x07,0xFC,0x1F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,
   0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x1F,0xC0,0xFF,0x03,0xFC,0x1F,0xC0,0xFF,0x03,0xFC,0x0F,0xE0,0xFF,0x01,0xF8,0x07,0xE0,0xFF,0x00,
   0xF0,0x1F,0xF8,0x7F,0x00,0xE0,0x7F,0xFC,0x3F,0x00,0x80,0x7F,0xFC,0x0F,0x00,0x00,0x7C,0xFC,0x00,0x00, // Code for char num 51
   0x00,0x00,0x80,0x0F,0x00,0x00,0x00,0xC0,0x0F,0x00,0x00,0x00,0xE0,0x0F,0x00,0x00,0x00,0xF0,0x0F,0x00,0x00,0x00,0xF0,0x0F,0x00,0x00,0x00,0xF8,0x0F,0x00,
   0x00,0x00,0xFC,0x0F,0x00,0x00,0x00,0xFE,0x0F,0x00,0x00,0x00,0xFE,0x0F,0x00,0x00,0x00,0xFE,0x0F,0x00,0x00,0x00,0xFE,0x0F,0x00,0x00,0x00,0xFE,0x0F,0x00,
   0x00,0x20,0xFE,0x0F,0x00,0x00,0x20,0xFE,0x0F,0x00,0x00,0x30,0xFE,0x0F,0x00,0x00,0x38,0xFE,0x0F,0x00,0x00,0x3C,0xFE,0x0F,0x00,0x00,0x3C,0xFE,0x0F,0x00,
   0x00,0x1E,0xFE,0x0F,0x00,0x00,0x1F,0xFE,0x0F,0x00,0x00,0x0F,0xFE,0x0F,0x00,0x80,0x07,0xFE,0x0F,0x00,0xC0,0x03,0xFE,0x0F,0x00,0xE0,0x03,0xFE,0x0F,0x00,
   0xE0,0x01,0xFE,0x0F,0x00,0xF0,0x00,0xFE,0x0F,0x00,0x78,0x00,0xFE,0x0F,0x00,0x7C,0x00,0xFE,0x0F,0x00,0x3C,0x00,0xFE,0x0F,0x00,0x1E,0x00,0xFE,0x0F,0x00,
   0xFF,0x3F,0xFE,0xFF,0x03,0xFF,0x3F,0xFE,0xFF,0x03,0xFF,0x3F,0xFE,0xFF,0x03,0xFF,0x3F,0xFE,0xFF,0x03,0xFE,0x3F,0xFE,0xFF,0x03,0x00,0x00,0xFE,0x0F,0x00,
   0x00,0x00,0xFE,0x0F,0x00,0x00,0x00,0xFE,0x0F,0x00,0x00,0x00,0xFE,0x0F,0x00,0x00,0x00,0xFE,0x0F,0x00,0x00,0x00,0xFE,0x0F,0x00,0x00,0xC0,0xFF,0x7F,0x00,
   0x00,0xF0,0xFF,0xFF,0x01,0x00,0xF0,0xFF,0xFF,0x01,0x00,0xF0,0xFF,0xFF,0x01,0x00,0x00,0x00,0x00,0x00, // Code for char num 52
   0x00,0x00,0x00,0x00,0x00,0xF0,0x7F,0x00,0x70,0x00,0xF0,0xFF,0xFF,0x7F,0x00,0xF0,0xFF,0xFF,0x7F,0x00,0xF0,0xFF,0xFF,0x7F,0x00,0xF0,0xFF,0xFF,0x7F,0x00,
   0xF0,0xFF,0xFF,0x3F,0x00,0xF0,0xFF,0xFF,0x1F,0x00,0xF0,0xFF,0xFF,0x0F,0x00,0xF0,0xFF,0xFF,0x03,0x00,0xF0,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x38,0x38,0x3E,0x00,0x00,
   0x38,0x3E,0xFE,0x01,0x00,0xB8,0x3F,0xFE,0x0F,0x00,0xF8,0x3F,0xFE,0x1F,0x00,0xF8,0x07,0xF8,0x3F,0x00,0xF8,0x01,0xE0,0x7F,0x00,0xF8,0x00,0xE0,0xFF,0x00,
   0x78,0x00,0xC0,0xFF,0x01,0x38,0x00,0xC0,0xFF,0x03,0x00,0x00,0xC0,0xFF,0x03,0x00,0x00,0xC0,0xFF,0x03,0x00,0x00,0xC0,0xFF,0x07,0xC0,0x01,0xC0,0xFF,0x07,
   0xF0,0x0F,0xC0,0xFF,0x07,0xF8,0x1F,0xC0,0xFF,0x07,0xFC,0x1F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,
   0xFE,0x3F,0xC0,0xFF,0x03,0xFE,0x3F,0xC0,0xFF,0x03,0xFE,0x1F,0xC0,0xFF,0x01,0xFC,0x1F,0xC0,0xFF,0x01,0xFC,0x0F,0xE0,0xFF,0x00,0xF8,0x07,0xE0,0x7F,0x00,
   0xF0,0x0F,0xF8,0x3F,0x00,0xE0,0x3F,0xFE,0x0F,0x00,0x80,0x3F,0xFE,0x03,0x00,0x00,0x3E,0x7E,0x00,0x00, // Code for char num 53
   0x00,0xF8,0xF8,0x00,0x00,0x00,0xFE,0xF8,0x07,0x00,0x00,0xFF,0xF8,0x1F,0x00,0xC0,0x7F,0xE0,0x3F,0x00,0xE0,0x3F,0xC0,0x7F,0x00,0xE0,0x1F,0xE0,0xFF,0x00,
   0xF0,0x1F,0xE0,0xFF,0x00,0xF8,0x1F,0xF0,0xFF,0x01,0xF8,0x1F,0xF0,0xFF,0x01,0xFC,0x1F,0xF0,0xFF,0x01,0xFC,0x1F,0xF0,0xFF,0x01,0xFC,0x1F,0xF0,0xFF,0x01,
   0xFE,0x1F,0xF0,0xFF,0x01,0xFE,0x1F,0xE0,0xFF,0x00,0xFE,0x1F,0xC0,0x7F,0x00,0xFE,0x1F,0x80,0x3F,0x00,0xFF,0x1F,0x00,0x0E,0x00,0xFF,0x1F,0x00,0x00,0x00,
   0xFF,0x1F,0x00,0x00,0x00,0xFF,0x1F,0xF8,0x07,0x00,0xFF,0x1F,0xFF,0x1F,0x00,0xFF,0x9F,0xFF,0x7F,0x00,0xFF,0x1F,0xFF,0xFF,0x00,0xFF,0x1F,0xF0,0xFF,0x01,
   0xFF,0x1F,0xC0,0xFF,0x03,0xFF,0x1F,0xC0,0xFF,0x07,0xFF,0x1F,0x80,0xFF,0x07,0xFF,0x1F,0x80,0xFF,0x07,0xFF,0x1F,0x80,0xFF,0x0F,0xFF,0x1F,0x80,0xFF,0x0F,
   0xFE,0x1F,0x80,0xFF,0x0F,0xFE,0x1F,0x80,0xFF,0x0F,0xFE,0x1F,0x80,0xFF,0x0F,0xFE,0x1F,0x80,0xFF,0x0F,0xFC,0x1F,0x80,0xFF,0x0F,0xFC,0x1F,0x80,0xFF,0x0F,
   0xFC,0x1F,0x80,0xFF,0x07,0xF8,0x1F,0x80,0xFF,0x07,0xF8,0x1F,0x80,0xFF,0x07,0xF0,0x1F,0x80,0xFF,0x03,0xE0,0x1F,0x80,0xFF,0x01,0xE0,0x3F,0xC0,0xFF,0x00,
   0xC0,0x7F,0xF0,0x7F,0x00,0x00,0xFF,0xF8,0x3F,0x00,0x00,0xFE,0xF8,0x0F,0x00,0x00,0xF8,0xF8,0x01,0x00, // Code for char num 54
   0x00,0xF8,0x01,0x00,0x00,0x1C,0xFE,0x1F,0x00,0x07,0x9C,0xFF,0x7F,0x80,0x07,0xDC,0xFF,0xFF,0xC3,0x07,0xFE,0xFF,0xFF,0xFF,0x07,0xFE,0xFF,0xFF,0xFF,0x07,
   0xFE,0xFF,0xFF,0xFF,0x03,0xFE,0xFF,0xFF,0xFF,0x03,0xFE,0xFF,0xFF,0xFF,0x01,0x3E,0xF8,0xFF,0xFF,0x01,0x1E,0xC0,0xFF,0xFF,0x00,0x1E,0x00,0xFE,0x3F,0x00,
   0x1E,0x00,0xE0,0x0F,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x00,0x00,0x00,0xC0,0x0F,0x00,0x00,0x00,0xE0,0x07,0x00,
   0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0xF8,0x03,0x00,0x00,0x00,0xFC,0x01,0x00,0x00,0x00,0xFE,0x01,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x80,0xFF,0x00,0x00,
   0x00,0xC0,0x7F,0x00,0x00,0x00,0xC0,0x7F,0x00,0x00,0x00,0xE0,0x7F,0x00,0x00,0x00,0xF0,0x3F,0x00,0x00,0x00,0xF0,0x3F,0x00,0x00,0x00,0xF8,0x3F,0x00,0x00,
   0x00,0xF8,0x3F,0x00,0x00,0x00,0xF8,0x3F,0x00,0x00,0x00,0xFC,0x3F,0x00,0x00,0x00,0xFC,0x3F,0x00,0x00,0x00,0xFC,0x7F,0x00,0x00,0x00,0xFC,0x7F,0x00,0x00,
   0x00,0xFC,0x7F,0x00,0x00,0x00,0xFC,0xFF,0x00,0x00,0x00,0xFC,0xFF,0x00,0x00,0x00,0xFC,0xFF,0x00,0x00,0x00,0xFC,0xFF,0x00,0x00,0x00,0xF8,0xFF,0x00,0x00,
   0x00,0xF8,0x7F,0x00,0x00,0x00,0xF0,0x7F,0x00,0x00,0x00,0xE0,0x3F,0x00,0x00,0x00,0xC0,0x0F,0x00,0x00, // Code for char num 55
   0x00,0xF8,0xF9,0x01,0x00,0x00,0xFF,0xF9,0x0F,0x00,0xC0,0xFF,0xF9,0x3F,0x00,0xE0,0x7F,0xE0,0x7F,0x00,0xF0,0x3F,0xC0,0xFF,0x00,0xF8,0x1F,0x80,0xFF,0x01,
   0xFC,0x1F,0x80,0xFF,0x03,0xFC,0x1F,0x80,0xFF,0x03,0xFE,0x1F,0x80,0xFF,0x07,0xFE,0x1F,0x80,0xFF,0x07,0xFE,0x1F,0x80,0xFF,0x07,0xFE,0x1F,0x80,0xFF,0x07,
   0xFE,0x1F,0x80,0xFF,0x07,0xFE,0x1F,0x80,0xFF,0x07,0xFE,0x1F,0x80,0xFF,0x07,0xFC,0x1F,0x80,0xFF,0x03,0xFC,0x1F,0x80,0xFF,0x03,0xF8,0x1F,0x80,0xFF,0x01,
   0xF8,0x1F,0x80,0xFF,0x01,0xF0,0x3F,0xC0,0xFF,0x00,0xE0,0xFF,0xF9,0x7F,0x00,0x80,0xFF,0xF9,0x1F,0x00,0x00,0xFF,0xF9,0x0F,0x00,0xC0,0xFF,0xF9,0x3F,0x00,
   0xF0,0x3F,0xC0,0xFF,0x00,0xF8,0x1F,0x80,0xFF,0x01,0xFC,0x1F,0x80,0xFF,0x03,0xFC,0x1F,0x80,0xFF,0x03,0xFE,0x1F,0x80,0xFF,0x07,0xFE,0x1F,0x80,0xFF,0x07,
   0xFF,0x1F,0x80,0xFF,0x0F,0xFF,0x1F,0x80,0xFF,0x0F,0xFF,0x1F,0x80,0xFF,0x0F,0xFF,0x1F,0x80,0xFF,0x0F,0xFF,0x1F,0x80,0xFF,0x0F,0xFF,0x1F,0x80,0xFF,0x0F,
   0xFF,0x1F,0x80,0xFF,0x0F,0xFE,0x1F,0x80,0xFF,0x07,0xFE,0x1F,0x80,0xFF,0x07,0xFE,0x1F,0x80,0xFF,0x07,0xFC,0x1F,0x80,0xFF,0x03,0xF8,0x3F,0xC0,0xFF,0x01,
   0xF0,0x7F,0xE0,0xFF,0x00,0xE0,0xFF,0xF9,0x7F,0x00,0x80,0xFF,0xF9,0x1F,0x00,0x00,0xFC,0xF9,0x03,0x00, // Code for char num 56
   0x00,0xF8,0xF8,0x00,0x00,0x00,0xFF,0xF8,0x03,0x00,0xC0,0xFF,0xF8,0x07,0x00,0xE0,0x7F,0xF0,0x1F,0x00,0xF0,0x3F,0xE0,0x3F,0x00,0xF8,0x1F,0xC0,0x3F,0x00,
   0xFC,0x1F,0xC0,0x7F,0x00,0xFC,0x1F,0xC0,0xFF,0x00,0xFE,0x1F,0xC0,0xFF,0x00,0xFE,0x1F,0xC0,0xFF,0x01,0xFF,0x1F,0xC0,0xFF,0x01,0xFF,0x1F,0xC0,0xFF,0x01,
   0xFF,0x1F,0xC0,0xFF,0x03,0xFF,0x1F,0xC0,0xFF,0x03,0xFF,0x1F,0xC0,0xFF,0x03,0xFF,0x1F,0xC0,0xFF,0x03,0xFF,0x1F,0xC0,0xFF,0x07,0xFF,0x1F,0xC0,0xFF,0x07,
   0xFF,0x1F,0xC0,0xFF,0x07,0xFE,0x1F,0xC0,0xFF,0x07,0xFE,0x1F,0xC0,0xFF,0x07,0xFE,0x3F,0xC0,0xFF,0x07,0xFC,0x7F,0xC0,0xFF,0x07,0xF8,0xFF,0xC7,0xFF,0x07,
   0xF0,0xFF,0xCF,0xFF,0x07,0xE0,0xFF,0xCF,0xFF,0x07,0xC0,0xFF,0xC7,0xFF,0x07,0x00,0xFE,0xC0,0xFF,0x07,0x00,0x00,0xC0,0xFF,0x07,0x00,0x00,0xC0,0xFF,0x07,
   0xC0,0x07,0xC0,0xFF,0x03,0xF0,0x1F,0xC0,0xFF,0x03,0xF8,0x3F,0xC0,0xFF,0x03,0xF8,0x3F,0xC0,0xFF,0x03,0xFC,0x7F,0xC0,0xFF,0x01,0xFC,0x7F,0xC0,0xFF,0x01,
   0xFC,0x7F,0xC0,0xFF,0x01,0xFC,0x7F,0xC0,0xFF,0x00,0xFC,0x7F,0xC0,0xFF,0x00,0xFC,0x3F,0xC0,0x7F,0x00,0xF8,0x3F,0xC0,0x3F,0x00,0xF0,0x1F,0xE0,0x3F,0x00,
   0xF0,0x3F,0xF0,0x1F,0x00,0xC0,0xFF,0xF8,0x07,0x00,0x80,0xFF,0xF8,0x03,0x00,0x00,0xFC,0xF8,0x00,0x00 // Code for char num 57
  };

/*const unsigned char Number_Font_Start = 0;
const unsigned char Number_Font_Length_Bytes = 230;
const unsigned char Number_Font_Width = 40;      // full bytes of pixels   8,16,24,32,40 etc
const unsigned char Number_Font_Height = 46;     //San Diego MEDIUM
const unsigned char Number_Font_Spacing = 2;*/

//GLCD FontName : Academy_Engraved_LET22x25
//GLCD FontSize : 22 x 25

const unsigned short Number_Font[] = {

   0x80,0x3F,0x00,0xE0,0xE0,0x00,0x50,0xC0,0x01,0x28,0x40,0x03,0x34,0x80,0x06,0x34,0x80,0x04,0x12,0x00,0x0D,0x1A,0x00,0x0D,0x19,0x00,0x19,0x19,0x00,0x19,0x19,0x00,0x19,0x19,0x00,0x19,0x19,0x00,0x19,0x19,0x00,0x19,0x19,0x00,0x19,0x19,0x00,0x19,0x19,0x00,0x19,0x1A,0x00,0x09,0x12,0x00,0x0D,0x34,0x80,0x0C,0x34,0x80,0x06,0x28,0x80,0x03,0x70,0x40,0x01,0xE0,0xA0,0x00,0xC0,0x7F,0x00, // Code for char num 48
   0x00,0x1C,0x00,0xE0,0x13,0x00,0x80,0x11,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x32,0x00,0x00,0x61,0x00,0xE0,0xFF,0x01, // Code for char num 49
   0x80,0x3F,0x00,0xC0,0xD0,0x00,0xE0,0xA0,0x01,0xD0,0x20,0x03,0xD0,0x40,0x03,0x50,0x40,0x02,0x60,0x40,0x02,0x00,0x40,0x03,0x00,0x20,0x03,0x00,0x20,0x03,0x00,0x90,0x01,0x00,0xD0,0x00,0x00,0x68,0x00,0x00,0x34,0x00,0x00,0x1C,0x00,0x00,0x0E,0x00,0x00,0x03,0x00,0x80,0x01,0x00,0x80,0x00,0x04,0x40,0x00,0x06,0x20,0x00,0x03,0xF0,0xFF,0x03,0xF0,0x3F,0x03,0x08,0x00,0x03,0xF8,0xFF,0x01, // Code for char num 50
   0xC0,0x3F,0x00,0x70,0x48,0x00,0x50,0xD0,0x00,0x48,0x90,0x01,0x68,0x90,0x01,0x30,0x90,0x01,0x00,0x90,0x01,0x00,0x90,0x00,0x00,0xC8,0x00,0x00,0x68,0x00,0x00,0x36,0x00,0x80,0xE9,0x00,0x00,0xC6,0x01,0x00,0x98,0x01,0x00,0x20,0x03,0x00,0x40,0x02,0x00,0x40,0x02,0x00,0x80,0x02,0x00,0x80,0x02,0x10,0x80,0x02,0x28,0x80,0x02,0x28,0x40,0x01,0x28,0xC0,0x00,0x70,0x60,0x00,0xE0,0x3F,0x00, // Code for char num 51
   0x00,0x60,0x00,0x00,0x50,0x00,0x00,0x48,0x00,0x00,0x48,0x00,0x00,0x4C,0x00,0x00,0x4A,0x00,0x00,0x49,0x00,0x00,0x49,0x00,0x80,0x48,0x00,0x40,0x48,0x00,0x20,0x48,0x00,0x20,0x48,0x00,0x10,0x48,0x08,0x08,0x48,0x08,0x04,0x48,0x06,0xFC,0xCF,0x07,0x02,0x48,0x06,0xFE,0xCF,0x07,0x00,0x48,0x00,0x00,0x48,0x00,0x00,0x48,0x00,0x00,0x48,0x00,0x00,0xC8,0x00,0x00,0x84,0x01,0x80,0xFF,0x07, // Code for char num 52
   0x80,0xFF,0x03,0x40,0x00,0x01,0xC0,0xFF,0x01,0xC0,0xFF,0x00,0x20,0x00,0x00,0x20,0x00,0x00,0x20,0x00,0x00,0x20,0x00,0x00,0xE0,0x07,0x00,0x90,0x3F,0x00,0x10,0x78,0x00,0xF0,0xC0,0x00,0x00,0x87,0x01,0x00,0x18,0x03,0x00,0x20,0x02,0x00,0x40,0x06,0x00,0x40,0x06,0x00,0x80,0x06,0x00,0x80,0x06,0x30,0x80,0x02,0x28,0x80,0x02,0x28,0x40,0x01,0x68,0xC0,0x01,0x70,0xF0,0x00,0xE0,0x3F,0x00, // Code for char num 53
   0x00,0xFE,0x00,0x80,0x47,0x03,0x40,0x83,0x02,0xA0,0x81,0x06,0x90,0x80,0x06,0xD0,0x00,0x01,0xC8,0x00,0x00,0x48,0x00,0x00,0x64,0x00,0x00,0x64,0x18,0x00,0x64,0xFF,0x00,0xE4,0x20,0x03,0x64,0x40,0x06,0x64,0x80,0x06,0x64,0x80,0x0C,0x64,0x80,0x0C,0x64,0x80,0x0C,0x64,0x80,0x0C,0x64,0x80,0x0C,0x68,0x80,0x0C,0x68,0x80,0x06,0xD0,0x80,0x06,0xE0,0x40,0x03,0xC0,0xC1,0x01,0x80,0xFF,0x00, // Code for char num 54
   0xE0,0xFF,0x07,0x20,0x00,0x06,0x10,0xFF,0x03,0xF0,0xFF,0x03,0x30,0x00,0x01,0x10,0x80,0x00,0x08,0x80,0x00,0x00,0x40,0x00,0x00,0x60,0x00,0x00,0x30,0x00,0x00,0x28,0x00,0x00,0x28,0x00,0x00,0x14,0x00,0x00,0x14,0x00,0x00,0x12,0x00,0x00,0x1A,0x00,0x00,0x1A,0x00,0x00,0x19,0x00,0x00,0x09,0x00,0x00,0x09,0x00,0x00,0x09,0x00,0x80,0x0C,0x00,0x80,0x0C,0x00,0x80,0x0C,0x00,0x80,0x0F,0x00, // Code for char num 55
   0x00,0x7F,0x00,0xC0,0xC0,0x00,0x60,0x80,0x01,0x50,0x00,0x03,0x30,0x00,0x03,0x50,0x00,0x03,0x50,0x00,0x03,0xD0,0x00,0x03,0x90,0x01,0x01,0x20,0x87,0x00,0x20,0x7C,0x00,0xC0,0xF0,0x00,0x80,0xC3,0x01,0x60,0x0C,0x03,0x30,0x30,0x06,0x28,0xC0,0x04,0x14,0x00,0x0D,0x14,0x00,0x09,0x14,0x00,0x0A,0x14,0x00,0x0A,0x14,0x00,0x06,0x38,0x00,0x05,0x28,0x00,0x03,0xF0,0x80,0x01,0xC0,0x7F,0x00, // Code for char num 56
   0x80,0x3F,0x00,0xE0,0xE0,0x00,0x50,0xA0,0x01,0x68,0x40,0x03,0x28,0x40,0x02,0x24,0x80,0x06,0x24,0x80,0x04,0x24,0x80,0x0C,0x24,0x80,0x0C,0x64,0x80,0x0C,0x64,0x80,0x0C,0x64,0x80,0x0C,0xC8,0x80,0x0C,0x90,0x81,0x0C,0x20,0xE3,0x0C,0xC0,0x9F,0x0C,0x00,0x80,0x0C,0x00,0x80,0x04,0x00,0x80,0x06,0x00,0x40,0x06,0x60,0x40,0x03,0xD0,0x40,0x01,0xD0,0xA0,0x01,0x90,0xD0,0x00,0xE0,0x3F,0x00 // Code for char num 57
 };

const unsigned char Number_Font_Start = 0;
const unsigned char Number_Font_Length_Bytes = 75;
const unsigned char Number_Font_Width = 24;      // full bytes of pixels   8,16,24,32,40 etc
const unsigned char Number_Font_Height = 25;     //Academy_Engraved_LET16x20
const unsigned char Number_Font_Spacing = 2;

#define Black_Out         Write_Data_SSD1963(0b0000000000000000)
#define Brown_Out         Write_Data_SSD1963(0b1111101000000000)
#define Red_Out           Write_Data_SSD1963(0b1111100000000000)
#define Orange_Out        Write_Data_SSD1963(0b1111001110000000)
#define Yellow_Out        Write_Data_SSD1963(0b1111111111100000)
#define Green_Out         Write_Data_SSD1963(0b0000011111100000)
#define Blue_Out          Write_Data_SSD1963(0b0000000000010111)
#define Violet_Out        Write_Data_SSD1963(0b1111000000011111)
#define Olive_Out         Write_Data_SSD1963(0b0011100111100011)
#define White_Out         Write_Data_SSD1963(0xFFFF)
#define Magenta_Out       Write_Data_SSD1963(0b1111100100001101)
#define Lime_Out          Write_Data_SSD1963(0b0111011111101100)
#define Baby_Powder_Out   Write_Data_SSD1963(0b1110111010001111)
#define Cyan_Out          Write_Data_SSD1963(0b0000011111111111)
#define Lavenderblush_Out Write_Data_SSD1963(0b1111101111000111)
#define Beige_Out         Write_Data_SSD1963(0b1011110000000000)

const unsigned char Black = 0;
const unsigned char Brown = 1;
const unsigned char Red = 2;
const unsigned char Orange = 3;
const unsigned char Yellow = 4;
const unsigned char Green = 5;
const unsigned char Blue = 6;
const unsigned char Violet = 7;
const unsigned char Olive = 8;
const unsigned char White = 9;
const unsigned char Magenta = 10;
const unsigned char Lime = 11;
const unsigned char Baby_Powder = 12;
const unsigned char Cyan = 13;
const unsigned char Lavenderblush = 14;
const unsigned char Beige = 15;

#define  SRAM_CS  LATJ4_bit

unsigned char TFT_DataPort at LATE;
unsigned char TFT_DataPort_Direction at TRISE;  //TRISE is lower PMD 0>7

sbit TFT_RST at LATB11_Bit; //RESET

sbit TFT_RS  at LATG12_BIT;  //TRD1/SQID1/RG12 PIN140

sbit TFT_CS  at LATG15_BIT;       //NEW 252 EFH

sbit TFT_RD  at LATC4_bit;  //PMRD  READ   EBIOE/AN19/RPC4/PMRD/RC4 PIN 13

sbit TFT_WR  at LATC3_bit;  //PMWR  WRITE  EBIWE/AN20/RPC3/PMWR/RC3 PIN 12

sbit TFT_RST_Direction at TRISB11_bit;    //RESET

sbit TFT_RS_Direction  at TRISG12_BIT;    //PIN 140 RG12

sbit TFT_CS_Direction  at TRISG15_BIT;      //NEW 252 EFH

sbit TFT_RD_Direction  at TRISC4_bit;    //PMRD  READ

sbit TFT_WR_Direction  at TRISC3_bit;    //PMWR  WRITE  EBIWE/AN20/RPC3/PMWR/RC3

#define  SD_Card_Chip_Select  LATE8_bit

void Set_Index(unsigned char index) {
  TFT_RS = 0;
  PMDOUT = index;
  while(PMMODE & 0x8000); //Busy bit
}

void Write_Command(unsigned char command ) {
  TFT_RS = 1;
  PMDOUT = command;
  while(PMMODE & 0x8000); //Busy bit
}

void Write_Data(unsigned int _data) {
  TFT_RS = 1;
  PMDOUT = _data;
  while(PMMODE & 0x8000); //Busy bit
}

void Write_Command_SSD1963(unsigned char Command) {
  TFT_RS = 0;  //RS = 0 NOT DATA  D/C = 0
  PMDOUT = Command;
  while(PMMODE & 0x8000); //Busy bit
}

void Write_Data_SSD1963(unsigned int _data) {
  TFT_RS = 1;   //RS = 1 = DATA   D/C = 1
  PMDOUT = _data;
  while(PMMODE & 0x8000); //Busy bit
}

void Init_16Bit_PMP() {

  PMMODE = 0;
  PMCONBits.DUALBUF = 1;   //DUAL BUFFER FOR IN AND OUT
  PMMODEbits.MODE = 2;     // Master 2     slave =1
  PMMODEbits.WAITB = 0;    //WAITB<1:0>: Data Setup before a Read/Write Strobe Wait States bits(1) 11 = Data wait of 4 TPB; multiplexed address phase of 4 TPB  10 = Data wait of 3 TPB; multiplexed address phase of 3 TPB 01 = Data wait of 2 TPB; multiplexed address phase of 2 TPB 00 = Data wait of 1 TPB; multiplexed address phase of 1 TPB (default)
  PMMODEbits.WAITM = 1;    //1111 = Wait of 16 TPB --0001 = Wait of 2 TPB-- 0000 = Wait of 1 TPB (default)STROBE PULSE WIDTH
  PMMODEbits.WAITE = 0;   //bit 1-0WAITE<1:0>: Data Hold After Read/Write Strobe Wait States bits(1)

  PMMODEbits.MODE16 = 1;   // 1 = 16-bit mode: a read or write to the data register invokes a single 16-bit transfer   For read operations  11 = Wait of 3 TPB  00 = Wait of 0 TPB (default)
  PMCONbits.CSF = 0;      //chip select bit
  PMCONbits.PTRDEN = 1;   //READ STROBE
  PMCONbits.PTWREN = 1;   //WRITE STROBE
  PMCONbits.PMPEN = 1;    //PMP ENABLE
  TFT_Set_Active(Set_Index,Write_Command,Write_Data);
}

void TFT_Set_DBC_SSD1963_BACKLIGHT(char value2) {  //PAGE54
  TFT_CS = 0;
  TFT_Set_Index_Ptr(0xBE);
  TFT_Write_Command_Ptr(0x06);
  TFT_Write_Command_Ptr(value2);
  TFT_Write_Command_Ptr(0x01); // PWM CONTROLLED BY DBC
  TFT_Write_Command_Ptr(0xFF); //MAX
  TFT_Write_Command_Ptr(0x00); //MIN
  TFT_Write_Command_Ptr(0x01);
  TFT_CS = 1;
}

void TFT_SET_MODE_SSD1963_5_Inch(){  // & newer 7"            Page 84 for timing

      TFT_CS_Direction = 0;
      TFT_RST_Direction = 0;
      TFT_RD_Direction = 0;
      TFT_WR_Direction = 0;
      TFT_RST = 0;
      Delay_ms(10);
      TFT_RST = 1;
      Delay_ms(10);
      TFT_RD = 1;
      TFT_WR = 1;

      TFT_CS = 0;

      TFT_Set_Index_Ptr(0x01);     //Software Reset
      Delay_ms(10);                //The Host Processor Must Wait 5ms Before Sending Any New Commands

      TFT_Set_Index_Ptr(0xE2);        // SET PLL
      TFT_Write_Command_Ptr(0x22);    // MULTIPLIER 10 MHz BASE CLOCK x 36 = 360  08/07/21
      TFT_Write_Command_Ptr(0x02);    // DIVIDES BY THIS NUMBER + 1 DIVIDE BY 3 = 120 MHz
      TFT_Write_Command_Ptr(17);      // DUMMY   08/07/21 WAS 0X04

      TFT_Set_Index_Ptr(0xE0);
      TFT_Write_Command_Ptr(0x01); // START PLL   BIT ZERO
      Delay_ms(50);               // Wait 100ms for the PLL to Lock 08/07/21
      TFT_Set_Index_Ptr(0xE0);
      TFT_Write_Command_Ptr(0x03); // BIT 1 = USE PLL AS OUTPUT BIT ZERO = ENABLE PLL 08/07/21

      TFT_Set_Index_Ptr(0x26);       // Set Gamma Curve
      TFT_Write_Command_Ptr(0x01);   // Gamma curve selection =0
    //TFT_Write_Command_Ptr(0x02);   // Gamma curve selection =1
    //TFT_Write_Command_Ptr(0x04);   // Gamma curve selection =2
    //TFT_Write_Command_Ptr(0x08);   // Gamma curve selection =3

      TFT_Set_Index_Ptr(0x0B);       //SET SCAN MODE
      TFT_Write_Command_Ptr(0x00);   //SET TFT MODE   top to bottom, left to right normal etc

      TFT_Set_Index_Ptr(0x0A);
      TFT_Write_Command_Ptr(0x1C);   //Power Mode

      TFT_Set_Index_Ptr(0xF0);       // Set Pixel Data Interface
      TFT_Write_Command_Ptr(0x03);   // 16-bit (565 format)   011 16-bit (565 format)

      TFT_Set_Index_Ptr(0x38);     //Exit Idle Mode

      TFT_Set_Index_Ptr(0x13);     //Enter Normal Mode;

      TFT_Set_Index_Ptr(0xBC);     //Set Post Proc
      TFT_Write_Command_Ptr(0x4D); //40 Set the contrast value     4D == 77  127 decimal is max    4D FOR CHINA DISPLAY
      TFT_Write_Command_Ptr(150);  //80 Set the brightness value   80 == 128 160 decimal is about max  85 FOR CHINA DISPLAY 08/07/21
      TFT_Write_Command_Ptr(0x60); //40 Set the saturation value   40 ==  64  127 decimal is max!  zero is black & white 6E FOR CHINA DISPLAY
      TFT_Write_Command_Ptr(0x01); //1 Enable the postprocessor

      TFT_Set_Index_Ptr(0xB0);          //SET LCD MODE   SIZE !!  08/07/21
      TFT_Write_Command_Ptr(32);        //Bit 5 Is 24 Bit Colour On TFT Panel All Active Low Pulses  MIDAS TFT PANEL IS 24 BIT
      TFT_Write_Command_Ptr(0);         //BIT 6 & 5TFT MODE NOT SERIAL
      TFT_Write_Command_Ptr(0x03);      //03 SET horizontal size=800+1 HightByte   !!!!!!!!!!!!
      TFT_Write_Command_Ptr(0x21);      //SET horizontal size=800+1 LowByte
      TFT_Write_Command_Ptr(0x01);      //SET vertical size=480+1 HightByte
      TFT_Write_Command_Ptr(0xE0);      //SET vertical size=480+1 LowByte
      TFT_Write_Command_Ptr(0x00);      //Even line RGB sequence / Odd line RGB sequence RGB

      // Set LSHIFT freq (DCLK from PLL)
      //  Typical DCLK for TM070RBH10 is 29.23MHz  NEW ==  Dot Data ClockD CLK - 33.26 - MHz  for 5" <<<<<<<<<<
      // 33.30 = 120 * (LCDC_FPR + 1) / 2^20
      // 5.3 (million) times  2^20  divide  120 = 46312    // y over x   on calculator

      TFT_Set_Index_Ptr(0xe6);       // pixel clock frequency  08/07/21
      TFT_Write_Command_Ptr(0x05);   // >>>LCD_FPR = 349526
      TFT_Write_Command_Ptr(0x55);   //40,000,076 Hz   40 MHz  349 526    08/07/21
      TFT_Write_Command_Ptr(0x00);

      /////////////////////////HORIZONTAL PERIOD BELOW /////  08/07/21  ///////////////////////////////////////

      TFT_Set_Index_Ptr(0xB4);          // Set Horizontal Period   MIN 862 TYPICAL 1056 MAX 1200
      TFT_Write_Command_Ptr(0x03);      // High byte of horizontal total period (display + non-display)   900 = 0X384
      TFT_Write_Command_Ptr(0x84);      // Low byte of the horizontal total period (display + non-display) 900
      TFT_Write_Command_Ptr(0x00);      // High byte of the non-display period between the start of the horizontal sync (LLINE) signal and the first display data. TOO LOW CAPTURE WONT WORK
      TFT_Write_Command_Ptr(68);        // 8 JULY 2021 MIN BLANKING SPEC IS 62 Low byte of the non-display period between the start of the horizontal sync (LLINE) signal and the first display data
      TFT_Write_Command_Ptr(8);         // Set the vertical sync pulse width
      TFT_Write_Command_Ptr(0x00);      // SET Hsync pulse start position
      TFT_Write_Command_Ptr(0x00);
      TFT_Write_Command_Ptr(0x00);      //SET Hsync pulse subpixel start position  //

      /////////////////////  08/07/21  //// VERTICAL PERIOD BELOW ////////////

      TFT_Set_Index_Ptr(0xB6);          //Set Vertical Period Set Vertical Period MIN = 510 TYPICAL = 525 MAX = 650  08/07/21
      TFT_Write_Command_Ptr(0x02);      // High byte of the vertical total (display + non-display) period in lines
      TFT_Write_Command_Ptr(0x12);      // Low byte INCREASES SYNC TIME AND BACK PORCH  (530) 480 + 40 +  10
      TFT_Write_Command_Ptr(0x00);      // 00
      TFT_Write_Command_Ptr(40);        //The non-display period in lines between the start of the frame and the first display data in line.
      TFT_Write_Command_Ptr(6);         //Set the vertical sync pulse width (LFRAME) in lines. TFT DOES NOT REQUIRE A SYNC PULSE
      TFT_Write_Command_Ptr(0x00);      //SET Vsync pulse start position  08/07/21
      TFT_Write_Command_Ptr(0x00);

      TFT_Set_Index_Ptr(0x36);          //Set Vertical Period
      TFT_Write_Command_Ptr(0b00000000);        //   BIT 7 = 0 Top to bottom, pages transferred from SP (Start Page) to EP (End Page).
                                                //   BIT 6 0 Left to right, columns transferred from SC (Start Column) to EC (End Column).
                                                //   BIT 5 0 Normal mode
                                                //   BIT 4 0 LCD refresh from top line to bottom line.
                                                //   BIT 3 0 RGB
                                                //   BIT 2 0 LCD refresh from left side to right side
                                                //   BIT 1 0 Normal
                                                //   BIT 0 0 Normal

      TFT_Set_Index_Ptr(0x29);       //SET display on     ************
      TFT_CS = 1;
}

static void Init_MCU() {

   ANSELA = 0;
   ANSELB = 0;
   ANSELC = 0;
   ANSELD = 0;
   ANSELE = 0;
   ANSELF = 0;
   ANSELG = 0;
   ANSELH = 0;
   ANSELJ = 0;

   TRISA = 0;
   TRISB = 0;
   TRISC = 0;
   TRISD = 0;
   TRISE = 0;
   TRISF = 0;
   TRISG = 0;
   TRISH = 0;
   TRISJ = 0;
   TRISK = 0;

   TRISD14_Bit = 1;
   SDI3R  = 0b1011; // = RPD14      PAGE 251     RD14 = SDI3    SPI3
   RPB10R = 0b0111; // = SDO3       PAGE 254     RB10 = SD03    SPI3

   PORTA=0;PORTB=0;PORTC=0;PORTD=0;PORTE=0;PORTF=0;PORTG=0; PORTH=0; PORTJ=0;  PORTK=0;

   TRISA14_Bit = 1;
   INT3R = 0b1101; // = RPA14   clock in pin RA14

   JTAGEN_bit = 0;
}


//////////////////FAT16////////////FAT16/////////    little-endian   Least Significant Number first !!  //////////////////////////////////////

//Offset |   Size    | Description           Implementing File I/O Functions Using Microchips Memory Disk Drive File System Library  AN1045
//  00h  |   3 Bytes | Jump Code + NOP
//  03h  |   8 Bytes | OEM Name
//  0Bh  |   1 Word  | Bytes per Sector ------ Sector size in bytes
//  0Dh  |   1 Byte  | Sectors per Cluster
//  0Eh  |   1 Word  | Start sector for FAT1 also known as Reserved Sectors
//  10h  |   1 Byte  | Number of Copies of FAT
//  11h  |   1 Word  | Number of Root Directory Entries 0x11 & 0x12    "Disk Parameter Block" (DPB).
//  13h  |   1 Word  | Number of Sectors in Partition Smaller than 32MB
//  15h  |   1 Byte  | Media Descriptor (F8h for Hard Disks)
//  16h  |   1 Word  | Sectors per FAT
//  18h  |   1 Word  | Sectors per Cluster   //Sectors per Track
//  1Ah  |   1 Word  | Number of Heads
//  1Ch  |   1 DWord | Number of Hidden Sectors in Partition
//  20h  |   1 DWord | Number of Sectors in Partition
//  24h  |   1 Word  | Logical Drive Number of Partition
//  26h  |   1 Byte  | Extended Signature (29h)
//  27h  |   1 DWord | Serial Number of Partition
//  2Bh  |  11 Bytes | Volume Name of Partition
//  36h  |   8 Bytes | FAT Name (FAT16)
//  3Eh  | 448 Bytes | Executable Code
//  1FEh |   2 Bytes | Executable Marker (55h AAh)

////////////////FAT16//////////////////FAT16//////////////////////////////////////////////////


//   Offset  |  Size     |  Description        Implementing File I/O Functions Using Microchips Memory Disk Drive File System Library  AN1045
//      00h  |  8 Bytes  |  Filename(1).
//      08h  |  3 bytes  |  File Extension.   //10  == zero
//      0Bh  |  1 Byte   |  File Attributes.
//      0Ch  |  1 Byte   |  Reserved.
//      0Dh  |  1 Byte   |  File Creation Time (ms portion).
//      0Eh  |  2 Bytes  |  File Creation Time (hours, minutes and seconds).
//      10h  |  2 bytes  |  File Creation Date.
//      12h  |  2 Bytes  |  Last Access Date.
//      14h  |  2 Bytes  |  Extended Address-Index.
//      16h  |  2 Bytes  |  Last Update Time (hours, minutes and seconds).
//      18h  |  2 Bytes  |  Last Update Date.
//      1Ah  |  2 Bytes  |  First Cluster of the File.
//      1Ch  |  4 Bytes  |  File Size. 4 bytes

unsigned char   Boot_Sector = 0;     // Sector number of Boot Record
unsigned long   Root_Directory = 0;  // Sector number of Root Directory
unsigned int    First_File_Allocation_Table; // Sector number of first FAT
unsigned int    Bytes_Per_Sector;
unsigned int    Sectors_Per_Cluster; //Sectors per Track
unsigned int    Start_Sector_for_FAT1;   //  Also known as Reserved_Sectors;  0Eh
unsigned short  Number_of_File_Allocation_Tables;
unsigned int    Number_of_Root_Directory_Entries;   // Number of Root Directory Entries
unsigned int    Sectors_Per_FAT;    //Sectors per FAT
unsigned long   Number_of_Sectors;
unsigned long   Number_Of_Hidden_Sectors;
unsigned char   byte_String[4];
unsigned char   int_String[7];
unsigned char   Long_String[14];
unsigned long   sector;
unsigned long   Cluster_Size;


unsigned char SectorBuffer[512];

void Get_Boot_Information_FAT16(){

  unsigned char   Byte20;
  unsigned int    Byte21;
  unsigned long   Byte22;
  unsigned long   Byte23;

  Bytes_Per_Sector = SectorBuffer[0x0B] + (256* SectorBuffer[0x0C]);
  Sectors_Per_Cluster = SectorBuffer[0x0D];
  Start_Sector_for_FAT1 = SectorBuffer[0x0E] + (256* SectorBuffer[0x0F]);  //INCLUDING RESERVED SECTORS
  Number_of_File_Allocation_Tables = Sectorbuffer[0x10];
  Number_of_Root_Directory_Entries = SectorBuffer[0x11] + (256 * SectorBuffer[0x12]);
  Sectors_Per_FAT = SectorBuffer[0x16] + (256 * SectorBuffer[0x17]);
  Byte20 = SectorBuffer[0x20];
  Byte21 = SectorBuffer[0x21];
  Byte22 = SectorBuffer[0x22];
  Byte23 = SectorBuffer[0x23];
  Number_of_Sectors =  Byte23<<24 | Byte22<<16 | Byte21<<8 | Byte20;

  First_File_Allocation_Table = Boot_Sector + Start_Sector_for_FAT1;
  Root_Directory = First_File_Allocation_Table + (Sectors_Per_FAT * Number_of_File_Allocation_Tables);
  //Sectors_Smaller_Than_32MB = Boot_SectorBuffer[0x13];
}

unsigned int Text_Line_Start_x = 30;
unsigned int Number_Start_x = 350;
unsigned char Font_Height = 26;

void Show_Boot_Information_FAT16(){

    TFT_Set_Font(Tahoma25x27,CL_WHITE,FO_HORIZONTAL);
    TFT_Fill_Screen(CL_Black);

    WordToStr(Number_of_Root_Directory_Entries,int_String);
    TFT_Write_Text(int_String,Number_Start_x,Font_Height*2);
    TFT_Write_Text("Root_Entries   =",Text_Line_Start_x,Font_Height*2);

    WordToStr(Sectors_Per_FAT,int_String);
    TFT_Write_Text(int_String,Number_Start_x,Font_Height*3);
    TFT_Write_Text("Sectors_Per_FAT   =",Text_Line_Start_x,Font_Height*3);

    LongWordToStr(Number_of_Sectors,Long_String);
    TFT_Write_Text(Long_String,Number_Start_x-1,Font_Height*4);
    TFT_Write_Text("Number_of_Sectors   =",Text_Line_Start_x,Font_Height*4);

    WordToStr(Sectors_Per_Cluster,int_String);
    TFT_Write_Text(int_String,Number_Start_x-2,Font_Height*5);
    TFT_Write_Text("Sectors_Per_Cluster =",Text_Line_Start_x,Font_Height*5);

    WordToStr(Start_Sector_for_FAT1,int_String);
    TFT_Write_Text(int_String,Number_Start_x-3,Font_Height*6);
    TFT_Write_Text("Start_+_Reserved  =",Text_Line_Start_x,Font_Height*6);

    ByteToStr(Number_of_File_Allocation_Tables,byte_String);
    TFT_Write_Text(byte_String,Number_Start_x,Font_Height*7);
    TFT_Write_Text("Number_of_FATs   =",Text_Line_Start_x,Font_Height*7);

    WordToStr(Bytes_Per_Sector,int_String);
    TFT_Write_Text(int_String,Number_Start_x,Font_Height*8);
    TFT_Write_Text("Bytes_Per_Sector   =",Text_Line_Start_x,Font_Height*8);

    Cluster_Size = Bytes_Per_Sector * Sectors_Per_Cluster;
    LongWordToStr(Cluster_Size,Long_String);
    TFT_Write_Text(Long_String,Number_Start_x-8,Font_Height*9);
    TFT_Write_Text("Cluster Size   =",Text_Line_Start_x,Font_Height*9);

    WordToStr(Root_Directory,int_String);
    TFT_Write_Text(int_String,Number_Start_x-1,Font_Height*10);
    TFT_Write_Text("Root Directory   =",Text_Line_Start_x,Font_Height*10);

 }

unsigned long Sectors_Per_FAT_32;
void Get_Boot_Information_FAT32(unsigned int SystemVolumeInfoStartsAt){

  unsigned char Byte32;
  unsigned int  Byte33;
  unsigned long Byte34;
  unsigned long Byte35;
  unsigned char Byte36;
  unsigned int  Byte37;
  unsigned long Byte38;
  unsigned long Byte39;

  Bytes_Per_Sector = SectorBuffer[0x0B] + (256 * SectorBuffer[0x0C]);
  Sectors_Per_Cluster = SectorBuffer[0x0D];
  Start_Sector_for_FAT1 = SectorBuffer[0x0E] + (256 * SectorBuffer[0x0F]);  //INCLUDING RESERVED
  
  Byte32 = SectorBuffer[32];
  Byte33 = SectorBuffer[33];
  Byte34 = SectorBuffer[34];
  Byte35 = SectorBuffer[35];
  Number_of_Sectors = Byte35<<24 | Byte34<<16 | Byte33<<8 | Byte32;
  //Number_of_Sectors = (Number_of_Sectors *512); CARD SIZE IN BYTES
  Number_of_File_Allocation_Tables = Sectorbuffer[0x10];
  Byte36 = SectorBuffer[36];
  Byte37 = SectorBuffer[37];
  Byte38 = SectorBuffer[38];
  Byte39 = SectorBuffer[39];
  Sectors_Per_FAT_32 = Byte39<<24 | Byte38<<16 | Byte37<<8 | Byte36;

  Root_Directory = (2* Sectors_Per_FAT_32) + Start_Sector_for_FAT1 + SystemVolumeInfoStartsAt; //THE ALL IMPORTANT ROOT DIRECTORY
}

void Show_Boot_Information_FAT32(){

    TFT_Set_Font(Tahoma25x27,CL_WHITE,FO_HORIZONTAL);
    TFT_Fill_Screen(CL_Black);

    LongWordToStr(Sectors_Per_FAT_32,Long_String);
    TFT_Write_Text(Long_String,Number_Start_x-9,Font_Height);
    TFT_Write_Text("Sectors_Per_FAT32   =",Text_Line_Start_x,Font_Height);

    LongWordToStr(Number_of_Sectors,Long_String);
    TFT_Write_Text(Long_String,Number_Start_x-3,Font_Height*2);
    TFT_Write_Text("Number_of_Sectors   =",Text_Line_Start_x,Font_Height*2);

    WordToStr(Sectors_Per_Cluster,int_String);
    TFT_Write_Text(int_String,Number_Start_x-5,Font_Height*3);
    TFT_Write_Text("Sectors_Per_Cluster =",Text_Line_Start_x,Font_Height*3);

    WordToStr(Start_Sector_for_FAT1,int_String);
    TFT_Write_Text(int_String,Number_Start_x,Font_Height*4);
    TFT_Write_Text("Start_+_Reserved  =",Text_Line_Start_x,Font_Height*4);

    ByteToStr(Number_of_File_Allocation_Tables,byte_String);
    TFT_Write_Text(byte_String,Number_Start_x,Font_Height*5);
    TFT_Write_Text("Number_of_FATs     =",Text_Line_Start_x,Font_Height*5);

    WordToStr(Bytes_Per_Sector,int_String);
    TFT_Write_Text(int_String,Number_Start_x,Font_Height*6);
    TFT_Write_Text("Bytes_Per_Sector   =",Text_Line_Start_x,Font_Height*6);

    Cluster_Size = Bytes_Per_Sector * Sectors_Per_Cluster;
    LongWordToStr(Cluster_Size,Long_String);
    TFT_Write_Text(Long_String,Number_Start_x-8,Font_Height*7);
    TFT_Write_Text("Cluster Size                      =",Text_Line_Start_x,Font_Height*7);

    WordToStr(Root_Directory,int_String);
    TFT_Write_Text(int_String,Number_Start_x+3,Font_Height*8);
    TFT_Write_Text("Root Directory   =",Text_Line_Start_x,Font_Height*8);
 }

unsigned int Background_Colour;
void Clear_Screen_SSD1963(unsigned int Colour){

     unsigned long i;
     TFT_CS = 0;
     Background_Colour = 0x00 | Colour;

     Write_Command_SSD1963(0x2A); //Set Column Address 800
     Write_Data_SSD1963(0x00);
     Write_Data_SSD1963(0x00);
     Write_Data_SSD1963(0x03);
     Write_Data_SSD1963(0x20);

     Write_Command_SSD1963(0x2B); //Set Row Address 480
     Write_Data_SSD1963(0);
     Write_Data_SSD1963(0);
     Write_Data_SSD1963(0x1);
     Write_Data_SSD1963(0xE0);

     Write_Command_SSD1963(0x2C);   // Write Memory Start, 0x2C

    switch (Colour)  {

     case 0:     for(i=0;i<384480;i++){
                 Black_Out;
                 } break;
     case 1:     for(i=0;i<384480;i++){
                 Brown_Out;
                 } break;
     case 2:     for(i=0;i<384480;i++){
                 Red_Out;
                 } break;
     case 3:     for(i=0;i<384480;i++){
                 Orange_Out;
                 } break;
     case 4:     for(i=0;i<384480;i++){
                 Yellow_Out;
                 } break;
     case 5:     for(i=0;i<384480;i++){
                 Green_Out;
                 } break;
     case 6:     for(i=0;i<384480;i++){
                 Blue_Out;
                 } break;
     case 7:     for(i=0;i<384480;i++){
                 Violet_Out;
                 } break;
     case 8:     for(i=0;i<384480;i++){
                 Olive_Out;
                 } break;
     case 9:     for(i=0;i<384480;i++){
                 White_Out;
                 } break;
     case 10:    for(i=0;i<384480;i++){
                 Magenta_Out;
                 } break;
     case 11:    for(i=0;i<384480;i++){
                 Lime_Out;
                 } break;
     case 12:    for(i=0;i<384480;i++){
                 Baby_Powder_Out;
                 } break;
     case 13:    for(i=0;i<384480;i++){
                 Cyan_Out;
                 } break;
     case 14:    for(i=0;i<384480;i++){
                 Lavenderblush_Out;
                 } break;
     case 15:    for(i=0;i<384480;i++){
                 Beige_Out;
                 } break;
     default:    for(i=0;i<384480;i++){
                 Write_Data_SSD1963(Colour);
                 } break;
    }
    TFT_CS = 1;
}


unsigned int Pixel;
void Get_Pixel_Colour(unsigned int Colour){

      switch (Colour)  {

     case 0:     Pixel = 0x00;
                 break;
     case 1:     Pixel = 0b1111101000000000;
                 break;
     case 2:     Pixel = 0b1111000000000000;
                 break;
     case 3:     Pixel = 0b1111001110000000;
                 break;
     case 4:     Pixel = 0b1111111111100000;
                 break;
     case 5:     Pixel = 0b0000001100000000;
                 break;
     case 6:     Pixel = 0b0000000000010111;
                 break;
     case 7:     Pixel = 0b1111000000011111;
                 break;
     case 8:     Pixel = 0b0011100111100011;
                 break;
     case 9:     Pixel = 0b1111111111111111;
                 break;
     case 10:    Pixel = 0b1111100100001101;
                 break;
     case 11:    Pixel = 0b0110011111100000;
                 break;
     case 12:    Pixel = 0b1110111010001111;
                 break;
     case 13:    Pixel = 0b0000011111111111;
                 break;
     case 14:    Pixel = 0b1111101111000111;
                 break;
     case 15:    Pixel = 0b1011110000000000;
                 break;
     default:    Pixel = Colour;
                 break;
    }

    switch (Background_Colour)  {

     case 0:     Background_Colour = 0x00;
                 break;
     case 1:     Background_Colour = 0b1111101000000000;
                 break;
     case 2:     Background_Colour = 0b1111000000000000;
                 break;
     case 3:     Background_Colour = 0b1111001110000000;
                 break;
     case 4:     Background_Colour = 0b1111111111100000;
                 break;
     case 5:     Background_Colour = 0b0000001100000000;
                 break;
     case 6:     Background_Colour = 0b0000000000010111;
                 break;
     case 7:     Background_Colour = 0b1111000000011111;
                 break;
     case 8:     Background_Colour = 0b0011100111100011;
                 break;
     case 9:     Background_Colour = 0b1111111111111111;
                 break;
     case 10:    Background_Colour = 0b1111100100001101;
                 break;
     case 11:    Background_Colour = 0b0110011111100000;
                 break;
     case 12:    Background_Colour = 0b1110111010001111;
                 break;
     case 13:    Background_Colour = 0b0000011111111111;
                 break;
     case 14:    Background_Colour = 0b1111101111000111;
                 break;
     case 15:    Background_Colour = 0b1011110000000000;
                 break;
     default:    break;
    }
}

void Set_Display_Numbers_SSD1963(unsigned int X_Position, unsigned int Y_Position){

     unsigned int Set_Start_Column = 0x00 | X_Position;
     unsigned int Set_Start_Row = 0x00 | Y_position;

     unsigned int Set_End_Column = Set_Start_Column + Number_Font_width-1; //(bytes -1 bit) 8 pixels = 1 byte, 16 pixels = 2 bytes
     unsigned int Set_End_Row = Set_Start_Row + Number_font_height;

     TFT_CS = 0;
     Write_Command_SSD1963(0x2A);               //Set Start Column               D/C = 0;
     Write_Data_SSD1963(Set_Start_column>>8);   //Start column number high byte  D/C = 1;
     Write_Data_SSD1963(Set_Start_column);      //Start column number low byte   D/C = 1;
     Write_Data_SSD1963(Set_End_Column>>8);     //End column number high byte    D/C = 1;
     Write_Data_SSD1963(Set_End_Column);        //End column number low byte     D/C = 1;

     Write_Command_SSD1963(0x2B);             //SET ROW ADDRESS                  D/C = 0;
     Write_Data_SSD1963(Set_Start_Row>>8);    //Start page(row)number high byte  D/C = 1;
     Write_Data_SSD1963(Set_Start_Row);       //Start page (row) number low byte D/C = 1;
     Write_Data_SSD1963(0x01);                //End page (row) number high byte  D/C = 1;
     Write_Data_SSD1963(0xE0);                //End page (row) number low byte   D/C = 1;

     Write_Command_SSD1963(0x2C);   //WRITE MEMORY START                         D/C = 0;

     TFT_CS = 1;
}

void Write_Number_Nine(unsigned int X_Position, unsigned int Y_Position, unsigned int Colour){
     static unsigned char x=0;
     static unsigned char dataout=0;
     static unsigned int i=1;
     static unsigned int jj=0;

     Get_Pixel_Colour(Colour);
     Set_Display_Numbers_SSD1963(X_Position,Y_Position);

     TFT_CS = 0;

     for(jj=Number_Font_Length_Bytes*9; jj<Number_Font_Length_Bytes*10; jj++){    //Number Three

       for(x=0; x<8; x++){

         dataout = Number_Font[jj] &i;

         if(dataout){
           Write_Data_SSD1963(Pixel);
          }else  {Write_Data_SSD1963(Background_Colour);}

         i=i<<1;

         if(i>128){
              i=1;}
        }
      }
      TFT_CS = 1;
}

void Write_Number_Eight(unsigned int X_Position, unsigned int Y_Position, unsigned int Colour){
     static unsigned char x=0;
     static unsigned char dataout=0;
     static unsigned int i=1;
     static unsigned int jj=0;

     Get_Pixel_Colour(Colour);
     Set_Display_Numbers_SSD1963(X_Position,Y_Position);

     TFT_CS = 0;

     for(jj=Number_Font_Length_Bytes*8; jj<Number_Font_Length_Bytes*9; jj++){    //Number Three

       for(x=0; x<8; x++){

         dataout = Number_Font[jj] &i;

         if(dataout){
            Write_Data_SSD1963(Pixel);
          }else  {Write_Data_SSD1963(Background_Colour);}

         i=i<<1;

         if(i>128){
              i=1;}
        }
      }
      TFT_CS = 1;
}

void Write_Number_Seven(unsigned int X_Position, unsigned int Y_Position, unsigned int Colour){
     static unsigned char x=0;
     static unsigned char dataout=0;
     static unsigned int i=1;
     static unsigned int jj=0;

     Get_Pixel_Colour(Colour);
     Set_Display_Numbers_SSD1963(X_Position,Y_Position);

     TFT_CS = 0;

     for(jj=Number_Font_Length_Bytes*7; jj<Number_Font_Length_Bytes*8; jj++){    //Number Three

       for(x=0; x<8; x++){

         dataout = Number_Font[jj] &i;

         if(dataout){
           Write_Data_SSD1963(Pixel);
          }else  {Write_Data_SSD1963(Background_Colour);}

          i=i<<1;

         if(i>128){
              i=1;}
        }
      }
      TFT_CS = 1;
}

void Write_Number_Six(unsigned int X_Position, unsigned int Y_Position, unsigned int Colour){
     static unsigned char x=0;
     static unsigned char dataout=0;
     static unsigned int i=1;
     static unsigned int jj=0;

     Get_Pixel_Colour(Colour);
     Set_Display_Numbers_SSD1963(X_Position,Y_Position);

     TFT_CS = 0;

     for(jj=Number_Font_Length_Bytes*6; jj<Number_Font_Length_Bytes*7; jj++){    //Number Three

       for(x=0; x<8; x++){

         dataout = Number_Font[jj] &i;

         if(dataout){
           Write_Data_SSD1963(Pixel);
          }else  {Write_Data_SSD1963(Background_Colour);}

         i=i<<1;

         if(i>128){
              i=1;}
        }
      }
      TFT_CS = 1;
}

void Write_Number_Five(unsigned int X_Position, unsigned int Y_Position, unsigned int Colour){
     static unsigned char x=0;
     static unsigned char dataout=0;
     static unsigned int i=1;
     static unsigned int jj=0;

     Get_Pixel_Colour(Colour);
     Set_Display_Numbers_SSD1963(X_Position,Y_Position);

     TFT_CS = 0;

     for(jj=Number_Font_Length_Bytes*5; jj<Number_Font_Length_Bytes*6; jj++){    //Number Three

       for(x=0; x<8; x++){

         dataout = Number_Font[jj] &i;

         if(dataout){
           Write_Data_SSD1963(Pixel);
          }else  {Write_Data_SSD1963(Background_Colour);}

         i=i<<1;

         if(i>128){
              i=1;}
        }
      }
      TFT_CS = 1;
}

void Write_Number_Four(unsigned int X_Position, unsigned int Y_Position, unsigned int Colour){
     static unsigned char x=0;
     static unsigned char dataout=0;
     static unsigned int i=1;
     static unsigned int jj=0;

     Get_Pixel_Colour(Colour);
     Set_Display_Numbers_SSD1963(X_Position,Y_Position);

     TFT_CS = 0;

     for(jj=Number_Font_Length_Bytes*4; jj<Number_Font_Length_Bytes*5; jj++){    //Number Three

       for(x=0; x<8; x++){

         dataout = Number_Font[jj] &i;

         if(dataout){
           Write_Data_SSD1963(Pixel);
          }else  {Write_Data_SSD1963(Background_Colour);}

         i=i<<1;

         if(i>128){
              i=1;}
        }
      }
      TFT_CS = 1;
}

void Write_Number_Three(unsigned int X_Position, unsigned int Y_Position, unsigned int Colour){
     static unsigned char x=0;
     static unsigned char dataout=0;
     static unsigned int i=1;
     static unsigned int jj=0;

     Get_Pixel_Colour(Colour);
     Set_Display_Numbers_SSD1963(X_Position,Y_Position);

     TFT_CS = 0;

     for(jj=Number_Font_Length_Bytes*3; jj<Number_Font_Length_Bytes*4; jj++){    //Number Three

       for(x=0; x<8; x++){

         dataout = Number_Font[jj] &i;

         if(dataout){
           Write_Data_SSD1963(Pixel);
          }else  {Write_Data_SSD1963(Background_Colour);}

         i=i<<1;

         if(i>128){
              i=1;}
        }
      }
      TFT_CS = 1;
}

void Write_Number_Two(unsigned int X_Position, unsigned int Y_Position, unsigned int Colour){
     static unsigned char x=0;
     static unsigned char dataout=0;
     static unsigned int i=1;
     static unsigned int jj=0;

     Get_Pixel_Colour(Colour);
     Set_Display_Numbers_SSD1963(X_Position,Y_Position);

     TFT_CS = 0;

     for(jj=Number_Font_Length_Bytes*2; jj<Number_Font_Length_Bytes*3; jj++){    //Number Two

       for(x=0; x<8; x++){

          dataout = Number_Font[jj] &i;

         if(dataout){
           Write_Data_SSD1963(Pixel);
          }else  {Write_Data_SSD1963(Background_Colour);}

         i=i<<1;

         if(i>128){
              i=1;}
        }
      }
      TFT_CS = 1;
}

void Write_Number_One(unsigned int X_Position, unsigned int Y_Position, unsigned int Colour){
     static unsigned char x=0;
     static unsigned char dataout=0;
     static unsigned int i=1;
     static unsigned int jj=0;

     Get_Pixel_Colour(Colour);
     Set_Display_Numbers_SSD1963(X_Position,Y_Position);

     TFT_CS = 0;

     for(jj=Number_Font_Length_Bytes*1; jj<Number_Font_Length_Bytes*2; jj++){    //Number One

      for(x=0; x<8; x++){

        dataout = Number_Font[jj] &i;

        if(dataout){
          Write_Data_SSD1963(Pixel);
         }else  {Write_Data_SSD1963(Background_Colour);}

        i=i<<1;

        if(i>128){
             i=1;}
       }
     }
     TFT_CS = 1;
}




void Write_Number_Zero(unsigned int X_Position, unsigned int Y_Position, unsigned int Colour){
     static unsigned char x = 0;
     static unsigned char dataout = 0;
     static unsigned int i = 1;
     static unsigned int jj = 0;

     Get_Pixel_Colour(Colour);
     Set_Display_Numbers_SSD1963(X_Position,Y_Position);
     TFT_CS = 0;

     for(jj=Number_Font_Start; jj<Number_Font_Length_Bytes*1; jj++){    //Number One

       for(x=0; x<8; x++){

         dataout = Number_Font[jj] &i;

         if(dataout){
           Write_Data_SSD1963(Pixel);
          }else { Write_Data_SSD1963(Background_Colour);}

          i=i<<1;

          if(i>128){
               i=1;}
        }
      }
      TFT_CS = 1;
}

void Write_Number_Space(unsigned int X_Position, unsigned int Y_Position){
     static unsigned int Colour;
     static unsigned int jj=0;

     Get_Pixel_Colour(Colour);
     Set_Display_Numbers_SSD1963(X_Position,Y_Position);
     TFT_CS = 0;

     for(jj=0; jj<Number_Font_Length_Bytes*8; jj++){    //Space
       Write_Data_SSD1963(Background_Colour);
      }
      TFT_CS = 1;
}

unsigned char DoneOne   = 1;
unsigned char DoneTwo   = 1;
unsigned char DoneThree = 1;
unsigned char DoneFour  = 1;
unsigned char DoneFive  = 1;
unsigned char DoneSix   = 1;
unsigned char DoneSeven = 1;
unsigned char DoneEight = 1;
unsigned char DoneNine  = 1;
unsigned char ValidEight = 0, ValidSeven = 0, ValidSix = 0, ValidFive = 0, ValidFour = 0, ValidThree = 0, ValidTwo = 0, ValidOne = 0, ValidZero = 0;

void Write_Number(unsigned long num,unsigned int X_Position,unsigned int Y_Position, unsigned char Font_Colour) {

   unsigned int Font_Width;
   unsigned int units_start;
   unsigned int tens_start;
   unsigned int hundreds_start;
   unsigned int thousands_start;
   unsigned int ten_thousands_start;
   unsigned int hundred_thousands_start;
   unsigned int million_start;
   unsigned int ten_million_start;
   unsigned int hundred_million_start;
   unsigned int Billion_Start;
   unsigned char Colour;
   static unsigned char numberstring[14];
   Colour = 0x00 | Font_Colour;
   Font_Width = Number_Font_Width + Number_Font_Spacing;

   if(num <=9){
     units_start = X_Position;}

   if(num >=10 && num<=99){
     DoneOne = 0;
     ValidEight = 1;
     units_start = X_Position +Font_Width*1;
     tens_start= X_Position;
    }

   if(num >=100 && num<=999){
     DoneTwo = 0;
     ValidSeven = 1;
     ValidEight = 1;
     units_start = X_Position + Font_Width *2;
     tens_start = X_Position + Font_Width*1;
     hundreds_start = X_Position;
    }

   if(num >=1000 && num<=9999){             //thousand
     DoneThree = 0;
     ValidSix = 1;
     ValidSeven = 1;
     ValidEight = 1;
     units_start = X_Position +Font_Width *3;
     tens_start = X_Position + Font_Width *2;
     hundreds_start = X_Position + Font_Width*1;
     thousands_start = X_Position;
    }

   if(num >=10000 && num<=99999){            //ten thousand to 99 thousand
     DoneFour = 0;
     ValidFive = 1;
     ValidSix = 1;
     ValidSeven = 1;
     ValidEight = 1;
     units_start = X_Position + Font_Width *4;
     tens_start = X_Position +Font_Width *3;
     hundreds_start = X_Position + Font_Width *2;
     thousands_start = X_Position + Font_Width*1;
     ten_thousands_start = X_Position;
    }

   if(num >=100000 && num<=999999){         //100 thousand  to 999 thousand
     DoneFive = 0;
     ValidFour = 1;
     ValidFive = 1;
     ValidSix = 1;
     ValidSeven = 1;
     ValidEight = 1;
     units_start = X_Position + Font_Width *5;
     tens_start = X_Position + Font_Width *4;
     hundreds_start = X_Position + Font_Width *3;
     thousands_start = X_Position+ Font_Width *2;
     ten_thousands_start = X_Position + Font_Width*1;
     hundred_thousands_start = X_Position;
    }

   if(num >=1000000 && num<=9999999){         // 1 million  to 9'999'999
     DoneSix = 0;
     ValidThree = 1;
     ValidFour = 1;
     ValidFive = 1;
     ValidSix = 1;
     ValidSeven = 1;
     ValidEight = 1;
     units_start = X_Position+ Font_Width *6;
     tens_start = X_Position + Font_Width *5;
     hundreds_start = X_Position +Font_Width *4;
     thousands_start = X_Position+ Font_Width *3;
     ten_thousands_start = X_Position+ Font_Width *2;
     hundred_thousands_start = X_Position+ Font_Width*1;
     million_start = X_Position;
    }

   if(num >=10000000 && num<=99999999){       //ten million to 99 million
     DoneSeven = 0;
     ValidTwo = 1;
     ValidThree = 1;
     ValidFour = 1;
     ValidFive = 1;
     ValidSix = 1;
     ValidSeven = 1;
     ValidEight = 1;
     units_start = X_Position+ Font_Width *7;
     tens_start = X_Position + Font_Width *6;
     hundreds_start = X_Position + Font_Width *5;
     thousands_start = X_Position+ Font_Width *4;
     ten_thousands_start = X_Position+ Font_Width *3;
     hundred_thousands_start = X_Position+ Font_Width *2;
     million_start = X_Position+ Font_Width*1;
     ten_million_start = X_position;
    }

   if(num >=100000000 && num<=999999999){       //humdred million
     DoneEight = 0;
     ValidOne = 1;
     ValidTwo = 1;
     ValidThree = 1;
     ValidFour = 1;
     ValidFive = 1;
     ValidSix = 1;
     ValidSeven = 1;
     ValidEight = 1;
     units_start = X_Position+ Font_Width *8;
     tens_start = X_Position + Font_Width *7;
     hundreds_start = X_Position + Font_Width *6;
     thousands_start = X_Position+ Font_Width *5;
     ten_thousands_start = X_Position+ Font_Width *4;
     hundred_thousands_start = X_Position+ Font_Width *3;
     million_start = X_Position+ Font_Width*2;
     ten_million_start = X_position+Font_Width;
     hundred_million_start = X_Position;
    }

   if(num >=1000000000 && num<=4294967295){      //Billion  A Long Will Only Count Up To 4 Billion 4'294'967'295
     DoneNine = 0;
     ValidZero = 1;
     ValidOne = 1;
     ValidTwo = 1;
     ValidThree = 1;
     ValidFour = 1;
     ValidFive = 1;
     ValidSix = 1;
     ValidSeven = 1;
     ValidEight = 1;
     units_start = X_Position + Font_Width *9;
     tens_start = X_Position + Font_Width *8;
     hundreds_start = X_Position + Font_Width *7;
     thousands_start = X_Position+ Font_Width *6;
     ten_thousands_start = X_Position+ Font_Width *5;
     hundred_thousands_start = X_Position+ Font_Width *4;
     million_start = X_Position+ Font_Width*3;
     ten_million_start = X_position+Font_Width*2;
     hundred_million_start = X_Position+Font_Width;
     Billion_Start = X_Position;
    }

   LongWordTostr(num,numberstring);     // Converts input unsigned long integer number to a string

   if(num<10 && DoneOne !=1){               //Clears The Tens Position Once
     Write_Number_Space(X_Position + Font_Width,Y_Position);
     DoneOne = 1;
     ValidEight = 0;
    }

   if(num<100 && DoneTwo !=1){             //Clears The Hundreds Position Once
     Write_Number_Space(X_Position + Font_Width *2,Y_Position);
     DoneTwo = 1;
     ValidSeven = 0;
    }

   if(num<1000 && DoneThree !=1){             //Clears The Thousands Position Once
     Write_Number_Space(X_Position + Font_Width *3,Y_Position);
     DoneThree = 1;
     ValidSix = 0;
    }

   if(num<10000 && DoneFour !=1){           //Clears The ten Thousands Position Once
     Write_Number_Space(X_Position + Font_Width *4,Y_Position);
     DoneFour = 1;
     ValidFive = 0;
    }

   if(num<100000 && DoneFive !=1){        //Clears The hundred Thousands Position Once
     Write_Number_Space(X_Position + Font_Width *5,Y_Position);
     DoneFive = 1;
     ValidFour = 0;
    }

   if(num<1000000 && DoneSix !=1){     //Clears The million Position Once
     Write_Number_Space(X_Position + Font_Width *6,Y_Position);
     DoneSix = 1;
     ValidThree = 0;
    }

   if(num<10000000 && DoneSeven !=1){     //Clears Ten million Position Once
     Write_Number_Space(X_Position + Font_Width *7,Y_Position);
     DoneSeven = 1;
     ValidTwo = 0;
    }

   if(num<100000000 && DoneEight !=1){     //Clears Hundred million Position Once
     Write_Number_Space(X_Position + Font_Width *8,Y_Position);
     DoneEight = 1;
     ValidOne = 0;
    }

   if(num<1000000000 && DoneNine !=1){     //Clears Billion Position Once
     Write_Number_Space(X_Position + Font_Width *9,Y_Position);
     DoneNine = 1;
     ValidZero = 0;
    }

    switch (numberstring[9]){  //units position

     case 48:    X_Position = units_start;
                 Write_Number_Zero(X_Position,Y_Position, Colour);
                 break;
     case 49:    X_Position = units_start;
                 Write_Number_One(X_Position,Y_Position, Colour);
                 break;
     case 50:    X_Position = units_start;
                 Write_Number_Two(X_Position,Y_Position, Colour);
                 break;
     case 51:    X_Position = units_start;
                 Write_Number_Three(X_Position,Y_Position, Colour);
                 break;
     case 52:    X_Position = units_start;
                 Write_Number_Four(X_Position,Y_Position, Colour);
                 break;
     case 53:    X_Position = units_start;
                 Write_Number_Five(X_Position,Y_Position, Colour);
                 break;
     case 54:    X_Position = units_start;
                 Write_Number_Six(X_Position,Y_Position, Colour);
                 break;
     case 55:    X_Position = units_start;
                 Write_Number_Seven(X_Position,Y_Position, Colour);
                 break;
     case 56:    X_Position = units_start;
                 Write_Number_Eight(X_Position,Y_Position, Colour);
                 break;
     case 57:    X_Position = units_start;
                 Write_Number_Nine(X_Position,Y_Position, Colour);
                 break;
     default:    break;
    }

   if(ValidEight){
     switch (numberstring[8]){ //tens position

     case 48:    X_Position = tens_start;
                 Write_Number_Zero(X_Position,Y_Position, Colour);
                 break;
     case 49:    X_Position = tens_start;
                 Write_Number_One(X_Position,Y_Position, Colour);
                 break;
     case 50:    X_Position = tens_start;
                 Write_Number_Two(X_Position,Y_Position, Colour);
                 break;
     case 51:    X_Position = tens_start;
                 Write_Number_Three(X_Position,Y_Position, Colour);
                 break;
     case 52:    X_Position = tens_start;
                 Write_Number_Four(X_Position,Y_Position, Colour);
                 break;
     case 53:    X_Position = tens_start;
                 Write_Number_Five(X_Position,Y_Position, Colour);
                 break;
     case 54:    X_Position = tens_start;
                 Write_Number_Six(X_Position,Y_Position, Colour);
                 break;
     case 55:    X_Position = tens_start;
                 Write_Number_Seven(X_Position,Y_Position, Colour);
                 break;
     case 56:    X_Position = tens_start;
                 Write_Number_Eight(X_Position,Y_Position, Colour);
                 break;
     case 57:    X_Position = tens_start;
                 Write_Number_Nine(X_Position,Y_Position, Colour);
                 break;
     default:    break;
    }}

    if(ValidSeven){
     switch (numberstring[7]){   //hundreds position

     case 48:    X_Position = hundreds_start;
                 Write_Number_Zero(X_Position,Y_Position, Colour);
                 break;
     case 49:    X_Position = hundreds_start;
                 Write_Number_One(X_Position,Y_Position, Colour);
                 break;
     case 50:    X_Position = hundreds_start;
                 Write_Number_Two(X_Position,Y_Position, Colour);
                 break;
     case 51:    X_Position = hundreds_start;
                 Write_Number_Three(X_Position,Y_Position, Colour);
                 break;
     case 52:    X_Position = hundreds_start;
                 Write_Number_Four(X_Position,Y_Position, Colour);
                 break;
     case 53:    X_Position = hundreds_start;
                 Write_Number_Five(X_Position,Y_Position, Colour);
                 break;
     case 54:    X_Position = hundreds_start;
                 Write_Number_Six(X_Position,Y_Position, Colour);
                 break;
     case 55:    X_Position = hundreds_start;
                 Write_Number_Seven(X_Position,Y_Position, Colour);
                 break;
     case 56:    X_Position = hundreds_start;
                 Write_Number_Eight(X_Position,Y_Position, Colour);
                 break;
     case 57:    X_Position = hundreds_start;
                 Write_Number_Nine(X_Position,Y_Position, Colour);
                 break;
     default:    break;
    }}

    if(ValidSix){
     switch (numberstring[6]){   //thousands position

     case 48:    X_Position = thousands_start;
                 Write_Number_Zero(X_Position,Y_Position, Colour);
                 break;
     case 49:    X_Position = thousands_start;
                 Write_Number_One(X_Position,Y_Position, Colour);
                 break;
     case 50:    X_Position = thousands_start;
                 Write_Number_Two(X_Position,Y_Position, Colour);
                 break;
     case 51:    X_Position = thousands_start;
                 Write_Number_Three(X_Position,Y_Position, Colour);
                 break;
     case 52:    X_Position = thousands_start;
                 Write_Number_Four(X_Position,Y_Position, Colour);
                 break;
     case 53:    X_Position = thousands_start;
                 Write_Number_Five(X_Position,Y_Position, Colour);
                 break;
     case 54:    X_Position = thousands_start;
                 Write_Number_Six(X_Position,Y_Position, Colour);
                 break;
     case 55:    X_Position = thousands_start;
                 Write_Number_Seven(X_Position,Y_Position, Colour);
                 break;
     case 56:    X_Position = thousands_start;
                 Write_Number_Eight(X_Position,Y_Position, Colour);
                 break;
     case 57:    X_Position = thousands_start;
                 Write_Number_Nine(X_Position,Y_Position, Colour);
                 break;
     default:    break;
    }}

    if(ValidFive){
     switch (numberstring[5]){   //ten thousands position

     case 48:    X_Position = ten_thousands_start;
                 Write_Number_Zero(X_Position,Y_Position, Colour);
                 break;
     case 49:    X_Position = ten_thousands_start;
                 Write_Number_One(X_Position,Y_Position, Colour);
                 break;
     case 50:    X_Position = ten_thousands_start;
                 Write_Number_Two(X_Position,Y_Position, Colour);
                 break;
     case 51:    X_Position = ten_thousands_start;
                 Write_Number_Three(X_Position,Y_Position, Colour);
                 break;
     case 52:    X_Position = ten_thousands_start;
                 Write_Number_Four(X_Position,Y_Position, Colour);
                 break;
     case 53:    X_Position = ten_thousands_start;
                 Write_Number_Five(X_Position,Y_Position, Colour);
                 break;
     case 54:    X_Position = ten_thousands_start;
                 Write_Number_Six(X_Position,Y_Position, Colour);
                 break;
     case 55:    X_Position = ten_thousands_start;
                 Write_Number_Seven(X_Position,Y_Position, Colour);
                 break;
     case 56:    X_Position = ten_thousands_start;
                 Write_Number_Eight(X_Position,Y_Position, Colour);
                 break;
     case 57:    X_Position = ten_thousands_start;
                 Write_Number_Nine(X_Position,Y_Position, Colour);
                 break;
     default:    break;
    }}

    if(ValidFour){
     switch (numberstring[4]){   //hundred thousands position

     case 48:    X_Position = hundred_thousands_start;
                 Write_Number_Zero(X_Position,Y_Position, Colour);
                 break;
     case 49:    X_Position = hundred_thousands_start;
                 Write_Number_One(X_Position,Y_Position, Colour);
                 break;
     case 50:    X_Position = hundred_thousands_start;
                 Write_Number_Two(X_Position,Y_Position, Colour);
                 break;
     case 51:    X_Position = hundred_thousands_start;
                 Write_Number_Three(X_Position,Y_Position, Colour);
                 break;
     case 52:    X_Position = hundred_thousands_start;
                 Write_Number_Four(X_Position,Y_Position, Colour);
                 break;
     case 53:    X_Position = hundred_thousands_start;
                 Write_Number_Five(X_Position,Y_Position, Colour);
                 break;
     case 54:    X_Position = hundred_thousands_start;
                 Write_Number_Six(X_Position,Y_Position, Colour);
                 break;
     case 55:    X_Position = hundred_thousands_start;
                 Write_Number_Seven(X_Position,Y_Position, Colour);
                 break;
     case 56:    X_Position = hundred_thousands_start;
                 Write_Number_Eight(X_Position,Y_Position, Colour);
                 break;
     case 57:    X_Position = hundred_thousands_start;
                 Write_Number_Nine(X_Position,Y_Position, Colour);
                 break;
     default:    break;
    }}

    if(ValidThree){
     switch (numberstring[3]){   //1 million position

     case 48:    X_Position = million_start;
                 Write_Number_Zero(X_Position,Y_Position, Colour);
                 break;
     case 49:    X_Position = million_start;
                 Write_Number_One(X_Position,Y_Position, Colour);
                 break;
     case 50:    X_Position = million_start;
                 Write_Number_Two(X_Position,Y_Position, Colour);
                 break;
     case 51:    X_Position = million_start;
                 Write_Number_Three(X_Position,Y_Position, Colour);
                 break;
     case 52:    X_Position = million_start;
                 Write_Number_Four(X_Position,Y_Position, Colour);
                 break;
     case 53:    X_Position = million_start;
                 Write_Number_Five(X_Position,Y_Position, Colour);
                 break;
     case 54:    X_Position = million_start;
                 Write_Number_Six(X_Position,Y_Position, Colour);
                 break;
     case 55:    X_Position = million_start;
                 Write_Number_Seven(X_Position,Y_Position, Colour);
                 break;
     case 56:    X_Position = million_start;
                 Write_Number_Eight(X_Position,Y_Position, Colour);
                 break;
     case 57:    X_Position = million_start;
                 Write_Number_Nine(X_Position,Y_Position, Colour);
                 break;
     default:    break;
    }}

    if(ValidTwo){
     switch (numberstring[2]){   //10 million position

     case 48:    X_Position = ten_million_start;
                 Write_Number_Zero(X_Position,Y_Position, Colour);
                 break;
     case 49:    X_Position = ten_million_start;
                 Write_Number_One(X_Position,Y_Position, Colour);
                 break;
     case 50:    X_Position = ten_million_start;
                 Write_Number_Two(X_Position,Y_Position, Colour);
                 break;
     case 51:    X_Position = ten_million_start;
                 Write_Number_Three(X_Position,Y_Position, Colour);
                 break;
     case 52:    X_Position = ten_million_start;
                 Write_Number_Four(X_Position,Y_Position, Colour);
                 break;
     case 53:    X_Position = ten_million_start;
                 Write_Number_Five(X_Position,Y_Position, Colour);
                 break;
     case 54:    X_Position = ten_million_start;
                 Write_Number_Six(X_Position,Y_Position, Colour);
                 break;
     case 55:    X_Position = ten_million_start;
                 Write_Number_Seven(X_Position,Y_Position, Colour);
                 break;
     case 56:    X_Position = ten_million_start;
                 Write_Number_Eight(X_Position,Y_Position, Colour);
                 break;
     case 57:    X_Position = ten_million_start;
                 Write_Number_Nine(X_Position,Y_Position, Colour);
                 break;
     default:    break;
    }}

    if(ValidOne){
     switch (numberstring[1]){   //100 million position

     case 48:    X_Position = hundred_million_start;
                 Write_Number_Zero(X_Position,Y_Position, Colour);
                 break;
     case 49:    X_Position = hundred_million_start;
                 Write_Number_One(X_Position,Y_Position, Colour);
                 break;
     case 50:    X_Position = hundred_million_start;
                 Write_Number_Two(X_Position,Y_Position, Colour);
                 break;
     case 51:    X_Position = hundred_million_start;
                 Write_Number_Three(X_Position,Y_Position, Colour);
                 break;
     case 52:    X_Position = hundred_million_start;
                 Write_Number_Four(X_Position,Y_Position, Colour);
                 break;
     case 53:    X_Position = hundred_million_start;
                 Write_Number_Five(X_Position,Y_Position, Colour);
                 break;
     case 54:    X_Position = hundred_million_start;
                 Write_Number_Six(X_Position,Y_Position, Colour);
                 break;
     case 55:    X_Position = hundred_million_start;
                 Write_Number_Seven(X_Position,Y_Position, Colour);
                 break;
     case 56:    X_Position = hundred_million_start;
                 Write_Number_Eight(X_Position,Y_Position, Colour);
                 break;
     case 57:    X_Position = hundred_million_start;
                 Write_Number_Nine(X_Position,Y_Position, Colour);
                 break;
     default:    break;
    }}

    if(ValidZero){
     switch (numberstring[0]){   //Billion position

     case 48:    X_Position = billion_start;
                 Write_Number_Zero(X_Position,Y_Position, Colour);
                 break;
     case 49:    X_Position = billion_start;
                 Write_Number_One(X_Position,Y_Position, Colour);
                 break;
     case 50:    X_Position = billion_start;
                 Write_Number_Two(X_Position,Y_Position, Colour);
                 break;
     case 51:    X_Position = billion_start;
                 Write_Number_Three(X_Position,Y_Position, Colour);
                 break;
     case 52:    X_Position = billion_start;
                 Write_Number_Four(X_Position,Y_Position, Colour);
                 break;
     case 53:    X_Position = billion_start;
                 Write_Number_Five(X_Position,Y_Position, Colour);
                 break;
     case 54:    X_Position = billion_start;
                 Write_Number_Six(X_Position,Y_Position, Colour);
                 break;
     case 55:    X_Position = billion_start;
                 Write_Number_Seven(X_Position,Y_Position, Colour);
                 break;
     case 56:    X_Position = billion_start;
                 Write_Number_Eight(X_Position,Y_Position, Colour);
                 break;
     case 57:    X_Position = billion_start;
                 Write_Number_Nine(X_Position,Y_Position, Colour);
                 break;
     default:    break;
    }}
}


void Set_Bus_Speeds(){

      /* unlock system for clock configuration */
    SYSKEY = 0x00000000;
    SYSKEY = 0xAA996655;
    SYSKEY = 0x556699AA;

    //000 = 1x divider  001 = 2x divider 010 = 3x divider  010 = 3x divider  011 = 4x divider  100 = 5x divider  101 = 6x divider  110 = 10x divider  111 = 12x divider

    // PB1DIV
    // Peripheral Bus 1 cannot be turned off, so there's no need to turn it on
    PB1DIVbits.PBDIV = 1; // Peripheral Bus 1 Clock Divisor Control (PBCLK1 is SYSCLK divided by 2)

    // PB2DIV
    PB2DIVbits.ON = 1; // Peripheral Bus 2 Output Clock Enable (Output clock is enabled)
    PB2DIVbits.PBDIV = 1; // Peripheral Bus 2 Clock Divisor Control (PBCLK2 is SYSCLK divided by 2)  Peripheral Bus 2 Clock drives i2C, spi, PMP

    // PB3DIV
    PB3DIVbits.ON = 1; // Peripheral Bus 3 Output Clock Enable (Output clock is enabled)
    PB3DIVbits.PBDIV = 1; // Peripheral Bus 3 Clock Divisor Control (PBCLK3 is SYSCLK divided by 2)

    // PB4DIV
    PB4DIVbits.ON = 1; // Peripheral Bus 4 Output Clock Enable (Output clock is enabled)
    while (!PB4DIVbits.PBDIVRDY); // Wait until it is ready to write to
    PB4DIVbits.PBDIV = 1; // Peripheral Bus 4 Clock Divisor Control (PBCLK4 is SYSCLK divided by 1)        //four drives ports

    // PB5DIV
    PB5DIVbits.ON = 1; // Peripheral Bus 5 Output Clock Enable (Output clock is enabled)
    PB5DIVbits.PBDIV = 1; // Peripheral Bus 5 Clock Divisor Control (PBCLK5 is SYSCLK divided by 2)

    // PB7DIV
    PB7DIVbits.ON = 1; // Peripheral Bus 7 Output Clock Enable (Output clock is enabled)
    PB7DIVbits.PBDIV = 1; // Peripheral Bus 7 Clock Divisor Control (PBCLK7 is SYSCLK divided by 1)

    // PB8DIV
    PB8DIVbits.ON = 1; // Peripheral Bus 8 Output Clock Enable (Output clock is enabled)
    PB8DIVbits.PBDIV = 1; // Peripheral Bus 8 Clock Divisor Control (PBCLK8 is SYSCLK divided by 2)

    // PRECON - Set up prefetch
    PRECONbits.PFMSECEN = 0; // Flash SEC Interrupt Enable (Do not generate an interrupt when the PFMSEC bit is set)
    PRECONbits.PREFEN = 0b11; // Predictive Prefetch Enable (Enable predictive prefetch for any address)  bit 5-4 PREFEN<1:0>: Predictive Prefetch Enable bits
    PRECONbits.PFMWS = 0b10; // PFM Access Time Defined in Terms of SYSCLK Wait States (Two wait states)
    CFGCONbits.ECCCON = 3;

    SYSKEY = 0x00;

}


void InitialiseSlowSPI(unsigned int Speed){                               //bus speed = 112'000'000  //divide by 280 = clock of 400 kHz
  SPI3_Init_Advanced(_SPI_MASTER, _SPI_8_BIT, Speed, _SPI_SS_DISABLE, _SPI_DATA_SAMPLE_MIDDLE, _SPI_CLK_IDLE_HIGH, _SPI_ACTIVE_2_IDLE);
}

void InitialiseFastSPI(unsigned char Speed){
  SPI3_Init_Advanced(_SPI_MASTER, _SPI_8_BIT, Speed, _SPI_SS_DISABLE, _SPI_DATA_SAMPLE_MIDDLE, _SPI_CLK_IDLE_HIGH, _SPI_ACTIVE_2_IDLE);
}
                                           // DEFINITIONS FOR MMC/SD CARD COMMANDS
#define CMD0   (64 + 0)                    // Software Reset Command
#define CMD1   (64 + 1)                    // Initiate initialization process.
#define ACMD41 (64 + 41)                   // SEND_OP_COND (SDC)
#define CMD8   (64 + 8)                    // COMMAND  8  VERSION CHECK  For only SDC V2. Check voltage range.
#define CMD9   (64 + 9)                    // SEND_CSD  Read CSD register.
#define CMD10  (64 + 10)                   // SEND_CID  Read CID register.
#define CMD12  (64 + 12)                   // STOP_TRANSMISSION  Stop to read data.
#define ACMD13 (64 + 13)                   // SD_STATUS (SDC)
#define CMD16  (64 + 16)                   // SET SECTOR LENGTH OF BYTES YOU WANT TO READ Change R/W block size.
#define CMD17  (64 + 17)                   // READ SINGLE SECTOR
#define CMD18  (64 + 18)                   // READ MULTIPLE SECTORS UNTIL INTERRUPTED BY A 'STOP TRANSMISSION' COMMAND
#define CMD23  (64 + 23)                   // SET SECTOR COUNT / NUMBER OF BLOCKS TO READ FOR CMD18 & CMD25
#define ACMD23 (64 + 23)                   // SET_WRITE SECTOR ERASE COUNT (SDC) For only SDC. Define number of blocks to pre-erase with next multi-block write command.
#define CMD24  (64 + 24)                   // SET WRITE ADDRESS FOR SINGLE SECTOR
#define CMD25  (64 + 25)                   // SET FIRST WRITE ADDRESS FOR MULTIPLE SECTORS
#define CMD41  (64 + 41)                   // SEND_OP_COND (ACMD)
#define CMD55  (64 + 55)                   // APP_CMD  Leading command before ACMD command.
#define CMD58  (64 + 58)                   // READ_OCR


unsigned int sdcardbuffer_X_position = 30;
unsigned int sdcardbuffer_Y_position = 30;


unsigned char File_Offset = 3;
unsigned char HighCapacity = 0;
unsigned long Delay = 25000;

void Read_Sector(unsigned long Address){

    unsigned char Counter = 0;
    unsigned char dummybuffer = 255;
    unsigned char junkBuffer[8];
    unsigned char loop17;
    unsigned long x = 0;

    loop17:

    SPI3_Write(0xFF);
    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD17);
    SPI3_Write(Address>>24);
    SPI3_Write(Address>>16);
    SPI3_Write(Address>>8);
    SPI3_Write(Address);
    SPI3_Write(0xFF);    //Checksum
    SPI3_Write(0xFF);    //Delay
    SD_Card_Chip_Select = 1;

    SD_Card_Chip_Select = 0;
    for(x=0; x<6; x++){         //16 GIG CARD REQUIRES 6 BYTES TO BE READ. ZERO TO 5 = 6.
      junkBuffer[x] = SPI3_Read(dummybuffer);
     }
    SD_Card_Chip_Select = 1;
    
    //Delay_us(1200);            //THIS IS REQUIRED ! THE LARGER 16 & 32 GIG NEED MORE TIME, THE 2 GIG CARDS NEED ONLY 500us
    for(x=0; x<Delay; x++){      //DELAY
     }
    
    if(junkBuffer[0] !=0){
       Counter++;
       Delay_ms(2);
       Delay+=10000;
      if(Counter >10){
        Clear_Screen_SSD1963(Red);
        TFT_Write_Text("SD   Card   Error   READ   SECTOR   CMD  17  IN    READ    SECTOR",2,200);
       }
       goto loop17;
     }

    SD_Card_Chip_Select = 0;

    for(x=0; x<File_Offset; x++){
      junkBuffer[x] = SPI3_Read(dummybuffer);
     }

    for(x=0; x<512; x++){
      SectorBuffer[x] = SPI3_Read(dummybuffer);     //<<<<<<<<<<<<<<DATA BUFFER HERE
     }

    for(x=0; x<2; x++){
      junkBuffer[x] = SPI3_Read(dummybuffer);
     }

    SD_Card_Chip_Select = 1;
}

Initialise_SDCARD(){

    unsigned char xpos = 30;
    unsigned char ypos = 30;
    unsigned int  x = 0;
    unsigned char Counter = 0;
    unsigned char HexString[4];
    unsigned char loop8;
    unsigned char loop55;
    unsigned char loop58;
    unsigned char loop16;
    unsigned char loop17;
    unsigned char dummybuffer = 255;
    unsigned char junkBufferOne[8];
    unsigned int  Volume_Boot_Record;     //Volume Boot Record
    unsigned int  Byte455 = 0;
    unsigned char Byte456 = 0;

    Delay_ms(400);           //TIME FOR SD CARD
    Counter = 0;
    loop8:

    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD8);        //Command  8  Version Check
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x01);
    SPI3_Write(0xAA);
    SPI3_Write(0x87);        //Checksum
    SPI3_Write(0xFF);        //Command Response Time
    SD_Card_Chip_Select =1;
    SPI3_Write(0xFF);        //Command Response Time

    SD_Card_Chip_Select =0;
    for(x=0; x<4; x++){
       SectorBuffer[x] = SPI3_Read(dummybuffer);
     }
    SD_Card_Chip_Select = 1;

    if(SectorBuffer[0] !=0){
       Counter++;
      if(Counter >5){
         Clear_Screen_SSD1963(Red);
         TFT_Write_Text("COMMAND   8   ERROR   INITIALISE_SDCARD",30,30);
       }
     }
    Delay_ms(10);
    
    /*Write_Number(Boot_SectorBuffer[0],sdcardbuffer_X_position,sdcardbuffer_Y_position,White);
    Write_Number(Boot_SectorBuffer[1],sdcardbuffer_X_position,sdcardbuffer_Y_position+30,White);
    Write_Number(Boot_SectorBuffer[2],sdcardbuffer_X_position,sdcardbuffer_Y_position+60,White);
    Write_Number(Boot_SectorBuffer[3],sdcardbuffer_X_position,sdcardbuffer_Y_position+90,White);
    Write_Number(8,sdcardbuffer_X_position+250,sdcardbuffer_Y_position,Black);
    Delay_ms(800);*/
    Counter = 0;
    loop55:

    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD55);      //PAGE 59 OF SD CARD ASSOCIATION STATES THAT COMMAND 55 SHALL ALWAYS PRECEDE AMCD41
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x87);        //Checksum
    SPI3_Write(0xFF);        //Command Response Time
    SD_Card_Chip_Select = 1;

    SD_Card_Chip_Select = 0;
    SectorBuffer[0] = SPI3_Read(dummybuffer);
    SD_Card_Chip_Select = 1;
    Delay_ms(10);
    
    /*sdcardbuffer_Y_position = 30;
    Write_Number(Boot_SectorBuffer[0],sdcardbuffer_X_position,sdcardbuffer_Y_position,White);
    Write_Number(55,sdcardbuffer_X_position+250,sdcardbuffer_Y_position,Black);*/
    //Clear_Screen_SSD1963(Lavenderblush);

    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD41);  //Command 41
    SPI3_Write(0x40);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x87);   //Checksum
    SPI3_Write(0XFF);   //Command Response Time
    SD_Card_Chip_Select = 1;

    SD_Card_Chip_Select = 0;
    SectorBuffer[0] = SPI3_Read(dummybuffer);
    SD_Card_Chip_Select = 1;
    Delay_ms(10);
    /*Write_Number(Boot_SectorBuffer[0],sdcardbuffer_X_position,sdcardbuffer_Y_position,Black);
    Write_Number(41,sdcardbuffer_X_position+250,sdcardbuffer_Y_position,Black);*/

    if(SectorBuffer[0] !=0){
       Counter++;
      if(Counter >6){
         Clear_Screen_SSD1963(Red);
         TFT_Write_Text("COMMAND   41   ERROR   INITIALISE_SDCARD",30,30);
       }
      goto loop55;
     }
     
    Counter = 0;
    loop58:
    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD58);       //Command 58
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0xFF);        //Checksum
    SPI3_Write(0xFF);        //Command Response Time
    SD_Card_Chip_Select = 1;

    SD_Card_Chip_Select = 0;
    for(x=0; x<5; x++){
      SectorBuffer[x] = SPI3_Read(dummybuffer);
     }
    SD_Card_Chip_Select = 1;          //  The Lower 12 Bits In The Return Value = 0x1AA Mean That The Card Is Sdc V2 And Can Work At A Voltage Range Of Between 2.7 To 3.6
    Delay_ms(5);

    if(SectorBuffer[0] !=0){
       Counter++;
      if(Counter >5){
         Clear_Screen_SSD1963(Red);
         TFT_Write_Text("COMMAND   58   ERROR   INITIALISE_SDCARD",30,30);
       }
      goto loop58;
     }
     
    if(SectorBuffer[1]==192){ //The 16 & 32 Gig Cards Do Not Like Fast Reading In Spi Mode.
      HighCapacity = 1;
     }
     
    if(SectorBuffer[1]==128){
      HighCapacity = 0;
      InitialiseFastSPI(8);
     }

    Delay_ms(10);

    loop16:

    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD16);     //Command 16
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x02);
    SPI3_Write(0x00);
    SPI3_Write(0x87);      //Checksum
    SPI3_Write(0xFF);      //Command Response Time
    SD_Card_Chip_Select = 1;

    SD_Card_Chip_Select = 0;
    junkBufferOne[0] = SPI3_Read(dummybuffer);
    SD_Card_Chip_Select = 1;
    Delay_ms(5);

    if(junkBufferOne[0] !=0){
       Counter++;
      if(Counter >5){
        Clear_Screen_SSD1963(Red);
        TFT_Write_Text("COMMAND   16   ERROR   INITIALISE_SDCARD",30,30);
       }
       goto loop16;
     }

    loop17:
    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD17);     //Command 17
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x87);       //Checksum
    SPI3_Write(0xFF);       //Command Response Time
    SD_Card_Chip_Select = 1;
    
    SD_Card_Chip_Select = 0;
    for(x=0; x<6; x++){      //MY 16 GIG REQUIRES ALL 48 BYTES TO BE READ
      junkBufferOne[x] = SPI3_Read(dummybuffer);
     }
    SD_Card_Chip_Select = 1;
    Delay_ms(5);

    if(junkBufferOne[0] !=0){
       Counter++;
      if(Counter >5){
        Clear_Screen_SSD1963(Red);
        TFT_Write_Text("COMMAND   17   ERROR   INITIALISE_SDCARD",30,30);
        Delay_ms(100);
       }
       goto loop17;
     }

    //--------READING THE DATA BUFFER HERE BELOW + CHECKSUM BYTES IN FRONT OF DATA AND AFTER----------

    SD_Card_Chip_Select = 0;

    for(x=0; x<File_Offset; x++){
       junkBufferOne[x] = SPI3_Read(255);
     }

    for(x=0; x<512; x++){
       SectorBuffer[x] = SPI3_Read(255);     //<<<<<<<<<<<<<<DATA BUFFER HERE
     }

    for(x=0; x<2; x++){
       junkBufferOne[x] = SPI3_Read(255);
     }
    SD_Card_Chip_Select = 1;
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
     /*Clear_Screen_SSD1963(Lavenderblush);
      sdcardbuffer_X_position = 3;
      sdcardbuffer_Y_position = 30;

      for(x=0; x<100; x++, sdcardbuffer_Y_position +=30){    //LAST 100 BYTES
         Write_Number(Boot_SectorBuffer[x],sdcardbuffer_X_position,sdcardbuffer_Y_position,Black);
         if(sdcardbuffer_Y_position>=440){
         sdcardbuffer_Y_position = 30;
         sdcardbuffer_X_position += 100; }
         Delay_ms(2);
       }

      Delay_ms(500);

      Clear_Screen_SSD1963(Yellow);
      sdcardbuffer_X_position = 3;
      sdcardbuffer_Y_position = 30;

      for(x=416; x<512; x++, sdcardbuffer_Y_position +=30){ //FIRST 100 BYTES
          Write_Number(Boot_SectorBuffer[x],sdcardbuffer_X_position,sdcardbuffer_Y_position,Black);
        if(sdcardbuffer_Y_position>=440){
          sdcardbuffer_Y_position = 30;
          sdcardbuffer_X_position += 100;
         }
         Delay_ms(8);
       }

      Delay_ms(2500);*/
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    sdcardbuffer_X_position = 3;
    sdcardbuffer_Y_position = 30;
    
    if(SectorBuffer[511] !=170){     //File Offset Is Wrong.
       //Clear_Screen_SSD1963(Red);
       //TFT_Write_Text("Wrong   Offset   ADJUSTING   ++",30,30);
       //Delay_ms(500);
      if(SectorBuffer[511]==85){
        File_Offset = File_Offset +1;
        goto loop17;          //Start Reading buffer again.
       }
     }

    if(SectorBuffer[511] !=170){    //File Offset Is Wrong.
       //Clear_Screen_SSD1963(Red);
       //TFT_Write_Text("Wrong   Offset   ADJUSTING   --",30,30);
       //Delay_ms(500);
      if(SectorBuffer[510]==170){
        File_Offset = File_Offset -1;
        goto loop17;          //Start Reading buffer again.
       }
     }

    if(SectorBuffer[511] !=170){    //File Offset Is Wrong.
       //Clear_Screen_SSD1963(Red);
       //TFT_Write_Text("Wrong   Offset   ADJUSTING   --",30,30);
       //Delay_ms(500);
      if(SectorBuffer[509]==170){
        File_Offset = File_Offset -2;
        goto loop17;                     //Start Reading buffer again.
       }
     }

    if(SectorBuffer[511] !=170){     //File Type is Wrong.
      if(SectorBuffer[510] !=170){
        if(SectorBuffer[512] !=170){
          Clear_Screen_SSD1963(Red);
          TFT_Write_Text("MAYBE  YOU  HAVE  A  CARD  TYPE   THAT   I   HAVE   NOT   SEEN   YET   LOL",30,30);
          Delay_ms(1000);
         }
       }
     }
       
    if(! HighCapacity){
      Get_Boot_Information_FAT16();        //does what it says   BOOT SECTOR IS READ DURING INITIALISE SDCARD
      Show_Boot_Information_FAT16();
      Delay_ms(1000);
     }

    if(HighCapacity && SectorBuffer[0]>0){
      Volume_Boot_Record = 0;
      Get_Boot_Information_FAT32(Volume_Boot_Record);
      Show_Boot_Information_FAT32();
      Delay_ms(2000);
     }

    if(HighCapacity && SectorBuffer[0]==0){
      Byte455 = SectorBuffer[455];
      Byte456 = SectorBuffer[456];
      Volume_Boot_Record = Byte455<<8 | Byte456;
      Read_Sector(Volume_Boot_Record);  //<<<<<<<<<<<<<
      Get_Boot_Information_FAT32(Volume_Boot_Record);   //VOLUME BOOT RECORD
      Show_Boot_Information_FAT32();
      Delay_ms(2000);
     }


    if(Number_of_Sectors >62000000){  //32 GIG  62,513,152
      InitialiseFastSPI(8);
     }

    if(HighCapacity && Number_of_Sectors> 7900000 && Number_of_Sectors <30900000){  //16 GIG NEEDS SLOWER CLOCK 30857216
      InitialiseFastSPI(8);
     }
     
    if(Number_of_Sectors <7900000){  //4 Gig = 7829504
      InitialiseFastSPI(8);
      Delay = 10000;
     }

    //Delay_ms(6000);
    Clear_Screen_SSD1963(Lavenderblush);
    Write_Number(SectorBuffer[511],300,60,White);
    Write_Number(File_Offset,300,90,White);
    ByteToHex(SectorBuffer[511], HexString);
    TFT_Write_Text(HexString,400,60);

    if(SectorBuffer[54] ==70){
      TFT_Write_Text("FAT16   Card   Initialised",260,30);
     }
     
    if(SectorBuffer[82] ==70){
      TFT_Write_Text("FAT32  Card  Installed",300,30);
     }
     
    if(HighCapacity){
      TFT_Write_Text("HC   CARD",150,30);
     }

    TFT_Write_Text("Boot  Signature  = ",2,60);
    TFT_Write_Text("File  Offset     = ",2,90);

    SPI3CONbits.DISSDO = 0;  //TURNS ON SERIAL DATA OUT
    Delay_ms(500);
    return HighCapacity;
}

struct File_Details{
    unsigned int  Location[10];
    unsigned long TotalFileSize;
    unsigned long Starting_Cluster[10];
}File;

void main(){

       //THIS C FILE WILL INITIALISE AN SD CARD WITHOUT A LIBRARY. JOHN B 07/10/21
       //IT WILL ALSO READ ANY SECTOR.
       //SIMPLE SPI  (Simple he says lol).
       //EVERY RESPONSE, IF CORRECT, WILL GIVE YOU A '0' IN THE FIRST BYTE.
       //IF YOU DON'T GET A '0' SEND THE COMMAND AGAIN.
       //THE DATA IN A SECTOR / BLOCK DOES NOT START AT ZERO SINCE THE CARD SENDS A RESPONSE TO THE REQUEST FIRST.
       //THE RESPONSE CAN BE 1, 3 OR 4 BYTES SO THERE IS AN OFFSET.
       //MY PROGRAM AUTOMATICALLY FIGURES OUT THE OFFSET SO THAT YOUR 512 BYTES OF DATA START AT ZERO.
       //MY 16 GIG AND 32 GIG CARDS FORMATTED WITH WINDOWS 10 HAD A NEARLY EMPTY SECTOR ZERO.
       //THE VOLUME BOOT RECORD WAS NOT THERE. ON MY 4 GIG CARD, IT WAS AT SECTOR ZERO
       //THUS FAR, I HAVE NOT FOUND THE CORRECT INFORMATION DETAILING WHY SOME CARDS HAVE THE VBR AT SECTOR 0 AND OTHERS DON'T.
       //THIS PROGRAM DETECTS WHERE THE VBR IS.
       //TO DONATE A COFFEE, SEE LINK WHERE YOU FOUND THIS SOFTWARE.
       //WORKS ON FAT16 2 GIG AND FAT32 4 GIG + HC 16 & 32 GIG AS SHOWN ON YOUTUBE 3/11/21   JOHN B
       //THIS PROGRAM WRITTEN WITH MIKRO C PRO FOR PIC32 ONLY SHOWS THE PICTURES ON HIGH CAPACITY CARDS. HOWEVER, IT DOES READ FAT16 SD CARDS TOO.
       //YOU ALREADY HAVE ACCESS TO MY PROGRAMS THAT READ FAT16 SD CARDS. THANK YOU.

      unsigned int  x = 0;
      unsigned char junkBufferOne[6];
      unsigned int  sdcardbuffer_X_position = 30;
      unsigned int  sdcardbuffer_Y_position = 30;
      unsigned char dummybuffer = 255;
      unsigned long SectorToRead;
      unsigned int  xpos = 30;
      unsigned int  ypos = 130;
      unsigned char readloop;
      unsigned int  Location;
      unsigned char FileNumber = 0;
      unsigned long SizeData31 = 0;
      unsigned long SizeData30 = 0;
      unsigned int  SizeData29 = 0;
      unsigned char SizeData28 = 0;
      unsigned long Byte13;
      unsigned long Byte12;
      unsigned int  Byte11;
      unsigned char Byte10;
      unsigned char Byte18;
      unsigned int  Byte19;
      unsigned int  StartingClusterData27 = 0;
      unsigned char StartingClusterData26 = 0;
      unsigned long ActualSector;
      unsigned int  Image_Width;
      unsigned int  Sectors_To_Read = 0;
      unsigned long Image_Data_Starts_At;
      unsigned int  Bytes_Left_To_Read;
      unsigned int  Start_Column = 0;
      unsigned int  Start_Row = 0;
      unsigned int  End_Column = 800-1;
      unsigned int  End_Row = 480-1;
      unsigned int  Data_Out;
      unsigned int  Max_Bytes = 512;
      unsigned long i = 0;
      unsigned long Sum0;
      unsigned long Sum1;
      unsigned long Root_Directory_In_Bytes;
      unsigned char xpos_4_FileNumber;
      unsigned char xpos_4_Location;
      unsigned int  xpos_4_Actual_Start_Sector;
      unsigned int  xpos_4_Start_Sector;

      Set_Bus_Speeds();
      Init_MCU();
      PRISS = 0x76543210;

      Init_16Bit_PMP();

      TFT_Init_SSD1963(800,480);
      TFT_SET_MODE_SSD1963_5_Inch();
      TFT_Set_DBC_SSD1963_BACKLIGHT(215);

      Clear_Screen_SSD1963(Blue);
      Delay_ms(400); //TIME FOR SD CARD
      
      TFT_Set_Font(Tahoma25x27,CL_NAVY,FO_HORIZONTAL);

      InitialiseSlowSPI(240);
      LATB10_bit = 1;     // RB10 = SERIAL DATA OUT SPI3
      LATB14_bit = 1;     // RB14 = CLOCK SPI 3


      for(x=0; x<10; x++){    // DUMMY CLOCKS  74 ARE REQUIRED.
         SPI3_Write(0xff);
       }

      SD_Card_Chip_Select = 0;
      SPI3_Write(CMD0);       //Software Reset Command
      SPI3_Write(0x00);
      SPI3_Write(0x00);
      SPI3_Write(0x00);
      SPI3_Write(0x00);
      SPI3_Write(0x95);       //0x95 Is Checksum For Software Reset
      SPI3_Write(0xFF);       // COMMAND RESPONSE TIME (NCR).
      SD_Card_Chip_Select = 1;

      SD_Card_Chip_Select =0;
      SectorBuffer[0] = SPI3_Read(dummybuffer);  // Response R1 with LSB Set To 1
      SD_Card_Chip_Select = 1;

      Write_Number(SectorBuffer[0],sdcardbuffer_X_position,sdcardbuffer_Y_position,White);
      Write_Number(0,sdcardbuffer_X_position+250,sdcardbuffer_Y_position,Black);
      Delay_ms(300);

      while(SectorBuffer[0] <1);

      Initialise_SDCARD();  //<<<<<<<<<<<<<<<<<<<FUNCTION
      
      if(! HighCapacity){
        SectorToRead = (512)*Root_Directory;
       }else {SectorToRead = Root_Directory;}

      Read_Sector(SectorToRead);
      //xpos = 30;
      TFT_Write_Char(SectorBuffer[0],xpos,ypos);       //DISPLAY SDCARD NAME
      TFT_Write_Char(SectorBuffer[1],xpos+=30,ypos);
      TFT_Write_Char(SectorBuffer[2],xpos+=30,ypos);
      TFT_Write_Char(SectorBuffer[3],xpos+=30,ypos);
      TFT_Write_Char(SectorBuffer[4],xpos+=30,ypos);
      TFT_Write_Char(SectorBuffer[5],xpos+=30,ypos);
      TFT_Write_Char(SectorBuffer[6],xpos+=30,ypos);
      TFT_Write_Char(SectorBuffer[7],xpos+=30,ypos);
      TFT_Write_Char(SectorBuffer[8],xpos+=30,ypos);
      TFT_Write_Char(SectorBuffer[9],xpos+=30,ypos);
      TFT_Write_Char(SectorBuffer[10],xpos+=30,ypos);
      TFT_Write_Char(SectorBuffer[11],xpos+=30,ypos);
      
      if(! HighCapacity){
        Write_Number(SectorToRead/512,xpos,ypos,Red);
      }else {Write_Number(SectorToRead,xpos,ypos,Red);}
      
      readloop:
      xpos = 30;
      ypos = 180;
      Location=8;   // jumps over system info

      while(Location <512){

        if(SectorBuffer[Location] >=65 && SectorBuffer[Location] <=90){

         if(SectorBuffer[Location+8] ==66 && SectorBuffer[Location+9] ==77){

             Write_Number(Location,370,ypos,Blue);
             TFT_Write_Char(SectorBuffer[Location],xpos,ypos);       //SHORT NAMES ARE ALWAYS CONVERTED TO UPPER CASE
             TFT_Write_Char(SectorBuffer[Location+1],xpos*2,ypos);
             TFT_Write_Char(SectorBuffer[Location+2],xpos*3,ypos);
             TFT_Write_Char(SectorBuffer[Location+3],xpos*4,ypos);
             TFT_Write_Char(SectorBuffer[Location+4],xpos*5,ypos);
             TFT_Write_Char(SectorBuffer[Location+5],xpos*6,ypos);
             TFT_Write_Char(SectorBuffer[Location+6],xpos*7,ypos);
             TFT_Write_Char(SectorBuffer[Location+7],xpos*8,ypos);
             TFT_Write_Char(SectorBuffer[Location+8],xpos*9,ypos);
             TFT_Write_Char(SectorBuffer[Location+9],xpos*10,ypos);
             TFT_Write_Char(SectorBuffer[Location+10],xpos*11,ypos);
             TFT_Write_Char(SectorBuffer[Location+11],xpos*12,ypos);

             ypos +=31;

           if(SectorBuffer[Location+10] ==80) {  //P
              FileNumber++;
              File.Location[FileNumber] = Location;
              SizeData31 =  SectorBuffer[File.Location[FileNumber]+31];
              SizeData30 =  SectorBuffer[File.Location[FileNumber]+30];
              SizeData29 =  SectorBuffer[File.Location[FileNumber]+29];
              SizeData28 =  SectorBuffer[File.Location[FileNumber]+28];
              File.TotalFileSize =  ((SizeData31<<24) |  (SizeData30<<16) |  (SizeData29<<8) | (SizeData28));
              StartingClusterData27 = SectorBuffer[File.Location[FileNumber]+27];
              StartingClusterData26 = SectorBuffer[File.Location[FileNumber]+26];
              File.Starting_Cluster[FileNumber] = (StartingClusterData27<<8) | StartingClusterData26;
            }

          }
        }
        Location += 8;
      }
      
     if(FileNumber<1){
       if(! HighCapacity){
         SectorToRead = (512)*Root_Directory;
        }else {SectorToRead = Root_Directory;}
         Root_Directory++;
         Read_Sector(SectorToRead);
         Write_Number(SectorToRead,600,ypos,Red);
         Delay_ms(500);
         Write_Number(FileNumber,370,ypos,Violet);
         goto readloop;
      }

     while(HighCapacity !=1);

     Write_Number(File.Starting_Cluster[1],370,ypos,Magenta);
     ypos+=31;

     if(HighCapacity){
       ActualSector = Root_Directory + (Sectors_Per_Cluster * (File.Starting_Cluster[1]-2));
       Write_Number(ActualSector,370,ypos,Magenta);
      }

     Delay_ms(4000);
     FileNumber = 1;  //<<<<

     Read_Sector(ActualSector);  //ACTUAL SECTOR WHERE PICTURE STARTS, NOT THE SAME AS START OF FILE.    //THIS IS READING THE BITMAP HEADER

     if(SectorBuffer[0] ==66){                      //CONFIRMS BIT ZERO AND BIT 1 = BM FOR BITMAP
       if(SectorBuffer[1] ==77){
       Clear_Screen_SSD1963(Yellow);
      }}else {Clear_Screen_SSD1963(Red);
            TFT_Write_Text("NOT   BM   BITMAP    ??",xpos+40,ypos);
        }
       
     Write_Number(ActualSector,40,100,Black);
     while(SectorBuffer[0] !=66);

     Byte10 = SectorBuffer[10];
     Byte11 = SectorBuffer[11];
     Byte12 = SectorBuffer[12];
     Byte13 = SectorBuffer[13];

     Image_Data_Starts_At = Byte13<<24 |  Byte12<<16 | Byte11<<8 | Byte10;  //  Does what it says
     ypos = 10;
     Write_Number(Image_Data_Starts_At,xpos,ypos,Red);
     Write_Number(File.TotalFileSize,xpos+360,ypos,Red);

     Byte18 = SectorBuffer[18];
     Byte19 = SectorBuffer[19];

     Image_Width = Byte19<<8 | Byte18;
     Write_Number(Image_Width,xpos+130,ypos,Red);

     Sectors_To_Read = File.TotalFileSize / 512;
     Bytes_Left_To_Read = File.TotalFileSize %512;

     if(Bytes_Left_To_Read>0){
        Sectors_To_Read +=1;  //   Sectors_To_Read = Sectors_To_Read+1;
      }
     ypos +=31;
     Write_Number(Sectors_To_Read,xpos,ypos,Blue);
     Write_Number(Bytes_Left_To_Read,xpos+250,ypos,Green);
     
     End_Column = Image_Width-1;

     TFT_CS = 0;
     Write_Command_SSD1963(0x2A);           //: Set Start Column               D/C = 0;
     Write_Data_SSD1963(Start_column>>8);   //: Start Column Number High Byte  D/C = 1;
     Write_Data_SSD1963(Start_column);      //: Start Column Number Low Byte   D/C = 1;
     Write_Data_SSD1963(End_Column>>8);     //: End Column Number High Byte    D/C = 1;
     Write_Data_SSD1963(End_Column);        //: End Column Number Low Byte     D/C = 1;

     Write_Command_SSD1963(0x2B);           //: SET ROW ADDRESS                D/C = 0;
     Write_Data_SSD1963(Start_Row>>8);      //: Start Row Number High Byte     D/C = 1;
     Write_Data_SSD1963(Start_Row);         //: Start Row Number Low Byte      D/C = 1;
     Write_Data_SSD1963(End_Row>>8);        //: End Row Number High Byte       D/C = 1;
     Write_Data_SSD1963(End_Row);           //: End Row Number Low Byte        D/C = 1;

     Write_Command_SSD1963(0x2C);   // Write Memory Start, 0x2C
     TFT_CS = 1;

     SRAM_CS = 1;
     TFT_CS = 0;
       
     Delay_ms(3000);

     for(i=0; i<Sectors_To_Read; i++){
         Read_Sector(ActualSector);                    //Read_Sector(512 * ActualSector);

       for(x = Image_Data_Starts_At; x<Max_Bytes; x=x+2){
         Data_Out = SectorBuffer[x] | SectorBuffer[x+1]<<8;
         Write_Data_SSD1963(Data_Out);
        }
       ActualSector++;
       Image_Data_Starts_At = 0;

       if(i==Sectors_To_Read-1){
         Max_Bytes = Bytes_Left_To_Read;
        }
      }
         TFT_CS = 1;
         

       Write_Number(Delay,1,450,Green);









}